<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::Exec Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1Exec.html">Exec</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classAsync_1_1Exec-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::Exec Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Execute external commands.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Async::Exec:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAsync_1_1Exec.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe739322c41d24dec3cc96919b5a71b0" id="r_afe739322c41d24dec3cc96919b5a71b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe739322c41d24dec3cc96919b5a71b0">Environment</a> = std::vector&lt;std::pair&lt;std::string,std::string&gt;&gt;</td></tr>
<tr class="separator:afe739322c41d24dec3cc96919b5a71b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32a192f041824be4c2cb49696d11cc75" id="r_a32a192f041824be4c2cb49696d11cc75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32a192f041824be4c2cb49696d11cc75">Exec</a> (const std::string &amp;cmdline=&quot;&quot;)</td></tr>
<tr class="memdesc:a32a192f041824be4c2cb49696d11cc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a32a192f041824be4c2cb49696d11cc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30eac5a19a328ebf2c0e3814026a2eb" id="r_af30eac5a19a328ebf2c0e3814026a2eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30eac5a19a328ebf2c0e3814026a2eb">~Exec</a> (void)</td></tr>
<tr class="memdesc:af30eac5a19a328ebf2c0e3814026a2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:af30eac5a19a328ebf2c0e3814026a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77878c5f9874c4753423df858b23882" id="r_aa77878c5f9874c4753423df858b23882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa77878c5f9874c4753423df858b23882">setCommandLine</a> (const std::string &amp;cmdline)</td></tr>
<tr class="memdesc:aa77878c5f9874c4753423df858b23882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the command line to use.  <br /></td></tr>
<tr class="separator:aa77878c5f9874c4753423df858b23882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b443f9cb39847cbf5d30e351880f3a4" id="r_a2b443f9cb39847cbf5d30e351880f3a4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b443f9cb39847cbf5d30e351880f3a4">command</a> (void) const</td></tr>
<tr class="memdesc:a2b443f9cb39847cbf5d30e351880f3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command name for the command.  <br /></td></tr>
<tr class="separator:a2b443f9cb39847cbf5d30e351880f3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1b080d975eb477c97152a902cf5f9" id="r_a6fa1b080d975eb477c97152a902cf5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa1b080d975eb477c97152a902cf5f9">appendArgument</a> (const std::string &amp;arg)</td></tr>
<tr class="memdesc:a6fa1b080d975eb477c97152a902cf5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a command line argument to a command.  <br /></td></tr>
<tr class="separator:a6fa1b080d975eb477c97152a902cf5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a9f2ea6bc2c4a6b8775847e656afb6" id="r_a45a9f2ea6bc2c4a6b8775847e656afb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45a9f2ea6bc2c4a6b8775847e656afb6">clearEnvironment</a> (void)</td></tr>
<tr class="memdesc:a45a9f2ea6bc2c4a6b8775847e656afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the environment.  <br /></td></tr>
<tr class="separator:a45a9f2ea6bc2c4a6b8775847e656afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036441e37eb878fd986510980232c535" id="r_a036441e37eb878fd986510980232c535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036441e37eb878fd986510980232c535">addEnvironmentVar</a> (const std::string &amp;name, const std::string &amp;val)</td></tr>
<tr class="memdesc:a036441e37eb878fd986510980232c535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an additional environment variable.  <br /></td></tr>
<tr class="separator:a036441e37eb878fd986510980232c535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd88cdf046f965be1dabf2613325192" id="r_a0dd88cdf046f965be1dabf2613325192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd88cdf046f965be1dabf2613325192">addEnvironmentVars</a> (const <a class="el" href="#afe739322c41d24dec3cc96919b5a71b0">Environment</a> &amp;env)</td></tr>
<tr class="memdesc:a0dd88cdf046f965be1dabf2613325192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple environment variables.  <br /></td></tr>
<tr class="separator:a0dd88cdf046f965be1dabf2613325192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010c9613b38e847e1cef2dd577641ab" id="r_ad010c9613b38e847e1cef2dd577641ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad010c9613b38e847e1cef2dd577641ab">nice</a> (int inc=10)</td></tr>
<tr class="memdesc:ad010c9613b38e847e1cef2dd577641ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the nice value for the child subprocess.  <br /></td></tr>
<tr class="separator:ad010c9613b38e847e1cef2dd577641ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e517458eda8710936679a8371f27c35" id="r_a2e517458eda8710936679a8371f27c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e517458eda8710936679a8371f27c35">setTimeout</a> (int time_s)</td></tr>
<tr class="memdesc:a2e517458eda8710936679a8371f27c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on the allowed runtime for the subprocess.  <br /></td></tr>
<tr class="separator:a2e517458eda8710936679a8371f27c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c82fe6f09b61de215ad8fcf45209d6" id="r_a63c82fe6f09b61de215ad8fcf45209d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63c82fe6f09b61de215ad8fcf45209d6">run</a> (void)</td></tr>
<tr class="memdesc:a63c82fe6f09b61de215ad8fcf45209d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the command.  <br /></td></tr>
<tr class="separator:a63c82fe6f09b61de215ad8fcf45209d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca3a8fac965d0fef51c1fd603db8edc" id="r_a8ca3a8fac965d0fef51c1fd603db8edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca3a8fac965d0fef51c1fd603db8edc">writeStdin</a> (const char *buf, int cnt)</td></tr>
<tr class="memdesc:a8ca3a8fac965d0fef51c1fd603db8edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to stdin on the subprocess.  <br /></td></tr>
<tr class="separator:a8ca3a8fac965d0fef51c1fd603db8edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217d7ce06b500b490592befb32d601c9" id="r_a217d7ce06b500b490592befb32d601c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a217d7ce06b500b490592befb32d601c9">writeStdin</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a217d7ce06b500b490592befb32d601c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to stdin on the subprocess.  <br /></td></tr>
<tr class="separator:a217d7ce06b500b490592befb32d601c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241adb880bc7f5cc4e1e5700f7e90335" id="r_a241adb880bc7f5cc4e1e5700f7e90335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241adb880bc7f5cc4e1e5700f7e90335">kill</a> (int sig=SIGTERM)</td></tr>
<tr class="memdesc:a241adb880bc7f5cc4e1e5700f7e90335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a UNIX signal to the subprocess.  <br /></td></tr>
<tr class="separator:a241adb880bc7f5cc4e1e5700f7e90335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acba07acacab1c02d46f2b0abab0c04" id="r_a1acba07acacab1c02d46f2b0abab0c04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1acba07acacab1c02d46f2b0abab0c04">closeStdin</a> (void)</td></tr>
<tr class="memdesc:a1acba07acacab1c02d46f2b0abab0c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the stdin pipe to the subprocess.  <br /></td></tr>
<tr class="separator:a1acba07acacab1c02d46f2b0abab0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f952b3ca74a6efbbc449e18e867e3" id="r_a371f952b3ca74a6efbbc449e18e867e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a371f952b3ca74a6efbbc449e18e867e3">ifExited</a> (void) const</td></tr>
<tr class="memdesc:a371f952b3ca74a6efbbc449e18e867e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the subprocess exited in a normal way.  <br /></td></tr>
<tr class="separator:a371f952b3ca74a6efbbc449e18e867e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de73fa218b90fa0a5c786a0405bf076" id="r_a8de73fa218b90fa0a5c786a0405bf076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de73fa218b90fa0a5c786a0405bf076">ifSignaled</a> (void) const</td></tr>
<tr class="memdesc:a8de73fa218b90fa0a5c786a0405bf076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the subprocess exited due to receiving a UNIX signal.  <br /></td></tr>
<tr class="separator:a8de73fa218b90fa0a5c786a0405bf076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230401ef736479aaa3e0024d9e67c2c4" id="r_a230401ef736479aaa3e0024d9e67c2c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a230401ef736479aaa3e0024d9e67c2c4">exitStatus</a> (void) const</td></tr>
<tr class="memdesc:a230401ef736479aaa3e0024d9e67c2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the exit code of the subprocess.  <br /></td></tr>
<tr class="separator:a230401ef736479aaa3e0024d9e67c2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dfc36296a9751a6ec9418d51bc39ff" id="r_a67dfc36296a9751a6ec9418d51bc39ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67dfc36296a9751a6ec9418d51bc39ff">termSig</a> (void) const</td></tr>
<tr class="memdesc:a67dfc36296a9751a6ec9418d51bc39ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the UNIX signal number that caused the subprocess to stop.  <br /></td></tr>
<tr class="separator:a67dfc36296a9751a6ec9418d51bc39ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade595a1b38dd3ac6084cc08d00c7bae2" id="r_ade595a1b38dd3ac6084cc08d00c7bae2"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const char *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade595a1b38dd3ac6084cc08d00c7bae2">stdoutData</a></td></tr>
<tr class="memdesc:ade595a1b38dd3ac6084cc08d00c7bae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess write to stdout.  <br /></td></tr>
<tr class="separator:ade595a1b38dd3ac6084cc08d00c7bae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a0307922271d9cc35f3acdfbf6313" id="r_a087a0307922271d9cc35f3acdfbf6313"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const char *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087a0307922271d9cc35f3acdfbf6313">stderrData</a></td></tr>
<tr class="memdesc:a087a0307922271d9cc35f3acdfbf6313"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess write to stderr.  <br /></td></tr>
<tr class="separator:a087a0307922271d9cc35f3acdfbf6313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11912f826cb67afc9d1d6d5a2e1ae714" id="r_a11912f826cb67afc9d1d6d5a2e1ae714"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11912f826cb67afc9d1d6d5a2e1ae714">stdoutClosed</a></td></tr>
<tr class="memdesc:a11912f826cb67afc9d1d6d5a2e1ae714"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess close its stdout.  <br /></td></tr>
<tr class="separator:a11912f826cb67afc9d1d6d5a2e1ae714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6" id="r_ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6">stderrClosed</a></td></tr>
<tr class="memdesc:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess close its stderr.  <br /></td></tr>
<tr class="separator:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733c546fb3499918f3c4b614173f870a" id="r_a733c546fb3499918f3c4b614173f870a"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a733c546fb3499918f3c4b614173f870a">exited</a></td></tr>
<tr class="memdesc:a733c546fb3499918f3c4b614173f870a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess exits.  <br /></td></tr>
<tr class="separator:a733c546fb3499918f3c4b614173f870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Execute external commands. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2013-10-26</dd></dl>
<p>This class is used to execute external commands. It essentially wraps the exec system call together with commonly used infrastructure in a convenient class.</p>
<p>This class depends on the SIGCHLD UNIX signal so it must not be used by another part of the application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncCppApplication_8h.html">AsyncCppApplication.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncExec_8h.html">AsyncExec.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncTimer_8h.html">AsyncTimer.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceAsync.html">Async</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handleOutput(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> cnt)</div>
<div class="line">{</div>
<div class="line">  cout &lt;&lt; buf;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handleExit(<a class="code hl_class" href="classAsync_1_1Exec.html">Exec</a> *exec)</div>
<div class="line">{</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Exited(\&quot;&quot;</span> &lt;&lt; exec-&gt;<a class="code hl_function" href="#a2b443f9cb39847cbf5d30e351880f3a4">command</a>() &lt;&lt; <span class="stringliteral">&quot;\&quot;): &quot;</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (exec-&gt;<a class="code hl_function" href="#a371f952b3ca74a6efbbc449e18e867e3">ifExited</a>())</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;exit_status=&quot;</span> &lt;&lt; exec-&gt;<a class="code hl_function" href="#a230401ef736479aaa3e0024d9e67c2c4">exitStatus</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (exec-&gt;<a class="code hl_function" href="#a8de73fa218b90fa0a5c786a0405bf076">ifSignaled</a>())</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;term_sig=&quot;</span> &lt;&lt; exec-&gt;<a class="code hl_function" href="#a67dfc36296a9751a6ec9418d51bc39ff">termSig</a>();</div>
<div class="line">  }</div>
<div class="line">  cout &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1CppApplication.html">CppApplication</a> app;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start a &quot;cat&quot; process and then run some text through it. Use the -n</span></div>
<div class="line">    <span class="comment">// option to make cat number the lines</span></div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1Exec.html">Exec</a> cat(<span class="stringliteral">&quot;/bin/cat -n&quot;</span>);</div>
<div class="line">  cat.stdoutData.connect(sigc::ptr_fun(handleOutput));</div>
<div class="line">  cat.stderrData.connect(sigc::ptr_fun(handleOutput));</div>
<div class="line">  cat.exited.connect(sigc::bind(sigc::ptr_fun(handleExit), &amp;cat));</div>
<div class="line">  cat.nice();</div>
<div class="line">  cat.run();</div>
<div class="line">  cat.writeStdin(<span class="stringliteral">&quot;Hello, Exec!\n&quot;</span>);</div>
<div class="line">  cat.writeStdin(<span class="stringliteral">&quot;This is a test\n&quot;</span>);</div>
<div class="line">  cat.closeStdin();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Try to run a command that does not exist</span></div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1Exec.html">Exec</a> xyz(<span class="stringliteral">&quot;/bin/xyz&quot;</span>);</div>
<div class="line">  xyz.exited.connect(sigc::bind(sigc::ptr_fun(handleExit), &amp;xyz));</div>
<div class="line">  xyz.run();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start a sort that just blocks and then set a timeout which kills it</span></div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1Exec.html">Exec</a> kill(<span class="stringliteral">&quot;/bin/sort&quot;</span>);</div>
<div class="line">  kill.exited.connect(sigc::bind(sigc::ptr_fun(handleExit), &amp;kill));</div>
<div class="line">  kill.setTimeout(1);</div>
<div class="line">  kill.run();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Sleep for two seconds then quit application</span></div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1Exec.html">Exec</a> sleep(<span class="stringliteral">&quot;/bin/sleep 2&quot;</span>);</div>
<div class="line">  sleep.exited.connect(sigc::bind(sigc::ptr_fun(handleExit), &amp;sleep));</div>
<div class="line">  sleep.exited.connect(mem_fun(app, &amp;CppApplication::quit));</div>
<div class="line">  sleep.run();</div>
<div class="line"> </div>
<div class="line">  app.<a class="code hl_function" href="classAsync_1_1CppApplication.html#a9a921d33644bbb18767fb4d599f53bf4">exec</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aAsyncCppApplication_8h_html"><div class="ttname"><a href="AsyncCppApplication_8h.html">AsyncCppApplication.h</a></div><div class="ttdoc">The core class for writing asyncronous cpp applications.</div></div>
<div class="ttc" id="aAsyncExec_8h_html"><div class="ttname"><a href="AsyncExec_8h.html">AsyncExec.h</a></div><div class="ttdoc">Execute external commands.</div></div>
<div class="ttc" id="aAsyncTimer_8h_html"><div class="ttname"><a href="AsyncTimer_8h.html">AsyncTimer.h</a></div><div class="ttdoc">Contains a single shot or periodic timer that emits a signal on timeout.</div></div>
<div class="ttc" id="aclassAsync_1_1CppApplication_html"><div class="ttname"><a href="classAsync_1_1CppApplication.html">Async::CppApplication</a></div><div class="ttdoc">An application class for writing non GUI applications.</div><div class="ttdef"><b>Definition</b> <a href="AsyncCppApplication_8h_source.html#l00136">AsyncCppApplication.h:137</a></div></div>
<div class="ttc" id="aclassAsync_1_1CppApplication_html_a9a921d33644bbb18767fb4d599f53bf4"><div class="ttname"><a href="classAsync_1_1CppApplication.html#a9a921d33644bbb18767fb4d599f53bf4">Async::CppApplication::exec</a></div><div class="ttdeci">void exec(void)</div><div class="ttdoc">Execute the application main loop.</div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html"><div class="ttname"><a href="classAsync_1_1Exec.html">Async::Exec</a></div><div class="ttdoc">Execute external commands.</div><div class="ttdef"><b>Definition</b> <a href="AsyncExec_8h_source.html#l00131">AsyncExec.h:132</a></div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html_a230401ef736479aaa3e0024d9e67c2c4"><div class="ttname"><a href="#a230401ef736479aaa3e0024d9e67c2c4">Async::Exec::exitStatus</a></div><div class="ttdeci">int exitStatus(void) const</div><div class="ttdoc">Read the exit code of the subprocess.</div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html_a2b443f9cb39847cbf5d30e351880f3a4"><div class="ttname"><a href="#a2b443f9cb39847cbf5d30e351880f3a4">Async::Exec::command</a></div><div class="ttdeci">const std::string &amp; command(void) const</div><div class="ttdoc">Get the command name for the command.</div><div class="ttdef"><b>Definition</b> <a href="AsyncExec_8h_source.html#l00161">AsyncExec.h:161</a></div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html_a371f952b3ca74a6efbbc449e18e867e3"><div class="ttname"><a href="#a371f952b3ca74a6efbbc449e18e867e3">Async::Exec::ifExited</a></div><div class="ttdeci">bool ifExited(void) const</div><div class="ttdoc">Check if the subprocess exited in a normal way.</div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html_a67dfc36296a9751a6ec9418d51bc39ff"><div class="ttname"><a href="#a67dfc36296a9751a6ec9418d51bc39ff">Async::Exec::termSig</a></div><div class="ttdeci">int termSig(void) const</div><div class="ttdoc">Read the UNIX signal number that caused the subprocess to stop.</div></div>
<div class="ttc" id="aclassAsync_1_1Exec_html_a8de73fa218b90fa0a5c786a0405bf076"><div class="ttname"><a href="#a8de73fa218b90fa0a5c786a0405bf076">Async::Exec::ifSignaled</a></div><div class="ttdeci">bool ifSignaled(void) const</div><div class="ttdoc">Check if the subprocess exited due to receiving a UNIX signal.</div></div>
<div class="ttc" id="anamespaceAsync_html"><div class="ttname"><a href="namespaceAsync.html">Async</a></div><div class="ttdoc">Namespace for the asynchronous programming classes.</div><div class="ttdef"><b>Definition</b> <a href="AsyncApplication_8h_source.html#l00075">AsyncApplication.h:76</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#_a0">AsyncExec_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00131">131</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afe739322c41d24dec3cc96919b5a71b0" name="afe739322c41d24dec3cc96919b5a71b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe739322c41d24dec3cc96919b5a71b0">&#9670;&#160;</a></span>Environment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afe739322c41d24dec3cc96919b5a71b0">Async::Exec::Environment</a> = std::vector&lt;std::pair&lt;std::string,std::string&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00134">134</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a32a192f041824be4c2cb49696d11cc75" name="a32a192f041824be4c2cb49696d11cc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a192f041824be4c2cb49696d11cc75">&#9670;&#160;</a></span>Exec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Async::Exec::Exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cmdline</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="af30eac5a19a328ebf2c0e3814026a2eb" name="af30eac5a19a328ebf2c0e3814026a2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30eac5a19a328ebf2c0e3814026a2eb">&#9670;&#160;</a></span>~Exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Async::Exec::~Exec </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a036441e37eb878fd986510980232c535" name="a036441e37eb878fd986510980232c535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036441e37eb878fd986510980232c535">&#9670;&#160;</a></span>addEnvironmentVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::addEnvironmentVar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an additional environment variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the environment variable </td></tr>
    <tr><td class="paramname">val</td><td>The value of the environment variable</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to add a variable to the environment for the process to be executed. It must be done before calling <a class="el" href="#a63c82fe6f09b61de215ad8fcf45209d6" title="Run the command.">run()</a>. </p>

</div>
</div>
<a id="a0dd88cdf046f965be1dabf2613325192" name="a0dd88cdf046f965be1dabf2613325192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd88cdf046f965be1dabf2613325192">&#9670;&#160;</a></span>addEnvironmentVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::addEnvironmentVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afe739322c41d24dec3cc96919b5a71b0">Environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple environment variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment variables to add</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to add multiple variables to the environment for the process to be executed. It must be done before calling <a class="el" href="#a63c82fe6f09b61de215ad8fcf45209d6" title="Run the command.">run()</a>. </p>

</div>
</div>
<a id="a6fa1b080d975eb477c97152a902cf5f9" name="a6fa1b080d975eb477c97152a902cf5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa1b080d975eb477c97152a902cf5f9">&#9670;&#160;</a></span>appendArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::appendArgument </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a command line argument to a command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The command line argument to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45a9f2ea6bc2c4a6b8775847e656afb6" name="a45a9f2ea6bc2c4a6b8775847e656afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a9f2ea6bc2c4a6b8775847e656afb6">&#9670;&#160;</a></span>clearEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::clearEnvironment </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the environment. </p>
<p>This function is used to clear the environment. It must be called before calling <a class="el" href="#a63c82fe6f09b61de215ad8fcf45209d6" title="Run the command.">run()</a>. It will clear both the environment inherited from the parent process as well as any environment variables added using the addEnvironmentVar(s) functions. </p>

</div>
</div>
<a id="a1acba07acacab1c02d46f2b0abab0c04" name="a1acba07acacab1c02d46f2b0abab0c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acba07acacab1c02d46f2b0abab0c04">&#9670;&#160;</a></span>closeStdin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::closeStdin </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stdin pipe to the subprocess. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise</dd></dl>
<p>This method is used to close the pipe from the parent process to the subprocess. This will indicate to the subprocess that the parent process is done sending data to it. </p>

</div>
</div>
<a id="a2b443f9cb39847cbf5d30e351880f3a4" name="a2b443f9cb39847cbf5d30e351880f3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b443f9cb39847cbf5d30e351880f3a4">&#9670;&#160;</a></span>command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Async::Exec::command </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the command name for the command. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the command name </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#a1">AsyncExec_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00161">161</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a id="a230401ef736479aaa3e0024d9e67c2c4" name="a230401ef736479aaa3e0024d9e67c2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230401ef736479aaa3e0024d9e67c2c4">&#9670;&#160;</a></span>exitStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Async::Exec::exitStatus </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the exit code of the subprocess. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the exit code (0-255) of the subprocess</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. The returned value is only meaningful if the ifExited function returns <em>true</em>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#a3">AsyncExec_demo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a371f952b3ca74a6efbbc449e18e867e3" name="a371f952b3ca74a6efbbc449e18e867e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371f952b3ca74a6efbbc449e18e867e3">&#9670;&#160;</a></span>ifExited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::ifExited </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the subprocess exited in a normal way. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if it was a normal exit or <em>false</em> otherwise</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#a2">AsyncExec_demo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8de73fa218b90fa0a5c786a0405bf076" name="a8de73fa218b90fa0a5c786a0405bf076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de73fa218b90fa0a5c786a0405bf076">&#9670;&#160;</a></span>ifSignaled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::ifSignaled </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the subprocess exited due to receiving a UNIX signal. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if it was a signal exit or <em>false</em> otherwise</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#a4">AsyncExec_demo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a241adb880bc7f5cc4e1e5700f7e90335" name="a241adb880bc7f5cc4e1e5700f7e90335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241adb880bc7f5cc4e1e5700f7e90335">&#9670;&#160;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::kill </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sig</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SIGTERM</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a UNIX signal to the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>The UNIX signal to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<a id="ad010c9613b38e847e1cef2dd577641ab" name="ad010c9613b38e847e1cef2dd577641ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad010c9613b38e847e1cef2dd577641ab">&#9670;&#160;</a></span>nice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::nice </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>inc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the nice value for the child subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inc</td><td>How much to increase the nice value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or else <em>false</em> </dd></dl>
<p>This function will modify the nice value of the subprocess. A positive value will increase the nice value (lower priority) and a negative value will decrease the nice value (higher priority). This function may be called both before and after the run method. </p>

</div>
</div>
<a id="a63c82fe6f09b61de215ad8fcf45209d6" name="a63c82fe6f09b61de215ad8fcf45209d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c82fe6f09b61de215ad8fcf45209d6">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::run </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the command. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise</dd></dl>
<p>This method is used to run the command specified using the constructor, setCommandLine and appendArgument. This function will return success as long as the fork call succeeds. If the command cannot be run for some reason, this function will still return success. Errors that occurr after the fork call will be handled through the "exited" signal. If the command cannot run for some reason, the exit code will be 255. </p>

</div>
</div>
<a id="aa77878c5f9874c4753423df858b23882" name="aa77878c5f9874c4753423df858b23882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77878c5f9874c4753423df858b23882">&#9670;&#160;</a></span>setCommandLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::setCommandLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cmdline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the command line to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdline</td><td>The command line to run</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to set the command line before the run method is called. The command line can also be set directly in the constructor. It's possible to append more arguments to the command line using the appendArgument method. </p>

</div>
</div>
<a id="a2e517458eda8710936679a8371f27c35" name="a2e517458eda8710936679a8371f27c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e517458eda8710936679a8371f27c35">&#9670;&#160;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::setTimeout </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>time_s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a timeout on the allowed runtime for the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_s</td><td>The timeout time in seconds</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to limit the maximum runtime for the subprocess. If the process runs for longer than the specified time, a SIGTERM will be sent to it. If the subprocess has not exited withing ten seconds, a SIGKILL will be sent to the subprocess. </p>

</div>
</div>
<a id="a67dfc36296a9751a6ec9418d51bc39ff" name="a67dfc36296a9751a6ec9418d51bc39ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dfc36296a9751a6ec9418d51bc39ff">&#9670;&#160;</a></span>termSig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Async::Exec::termSig </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the UNIX signal number that caused the subprocess to stop. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the UNIX signal number</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. The returned value is only meaningful if the ifSignaled function returns <em>true</em>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncExec_demo_8cpp-example.html#a5">AsyncExec_demo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8ca3a8fac965d0fef51c1fd603db8edc" name="a8ca3a8fac965d0fef51c1fd603db8edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca3a8fac965d0fef51c1fd603db8edc">&#9670;&#160;</a></span>writeStdin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::writeStdin </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to stdin on the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write data from </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<a id="a217d7ce06b500b490592befb32d601c9" name="a217d7ce06b500b490592befb32d601c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217d7ce06b500b490592befb32d601c9">&#9670;&#160;</a></span>writeStdin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::writeStdin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to stdin on the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string buffer to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a733c546fb3499918f3c4b614173f870a" name="a733c546fb3499918f3c4b614173f870a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733c546fb3499918f3c4b614173f870a">&#9670;&#160;</a></span>exited</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::exited</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess exits. </p>
<p>This signal will be emitted when the subprocess exits. After that the methods ifExited, ifSignaled, exitStatus and termSig may be used to find out what caused the subprocess to exit. </p>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00343">343</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a id="ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6" name="ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6">&#9670;&#160;</a></span>stderrClosed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::stderrClosed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess close its stderr. </p>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00334">334</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a id="a087a0307922271d9cc35f3acdfbf6313" name="a087a0307922271d9cc35f3acdfbf6313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a0307922271d9cc35f3acdfbf6313">&#9670;&#160;</a></span>stderrData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, const char *, int&gt; Async::Exec::stderrData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess write to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the data </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of valid bytes in the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This signal is emitted when a subprocess write to its stderr. The data will be zero terminated. </p>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00324">324</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a id="a11912f826cb67afc9d1d6d5a2e1ae714" name="a11912f826cb67afc9d1d6d5a2e1ae714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11912f826cb67afc9d1d6d5a2e1ae714">&#9670;&#160;</a></span>stdoutClosed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::stdoutClosed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess close its stdout. </p>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00329">329</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a id="ade595a1b38dd3ac6084cc08d00c7bae2" name="ade595a1b38dd3ac6084cc08d00c7bae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade595a1b38dd3ac6084cc08d00c7bae2">&#9670;&#160;</a></span>stdoutData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, const char *, int&gt; Async::Exec::stdoutData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess write to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the data </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of valid bytes in the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This signal is emitted when a subprocess write to its stdout. The data will be zero terminated. </p>

<p class="definition">Definition at line <a class="el" href="AsyncExec_8h_source.html#l00314">314</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
