<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::StateMachine&lt; ContextT, StateTopT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAsync_1_1StateMachine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::StateMachine&lt; ContextT, StateTopT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements a hierarchial state machine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6d630fbcb20c6a17bb2de8deed8353f5" id="r_a6d630fbcb20c6a17bb2de8deed8353f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d630fbcb20c6a17bb2de8deed8353f5">StateTopBaseT</a> = <a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a>&lt;ContextT,StateTopT&gt;</td></tr>
<tr class="memdesc:a6d630fbcb20c6a17bb2de8deed8353f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias simplifying access to the top state base type.  <br /></td></tr>
<tr class="separator:a6d630fbcb20c6a17bb2de8deed8353f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab840087fe74ebea2b3dd2e369eb26cac" id="r_ab840087fe74ebea2b3dd2e369eb26cac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab840087fe74ebea2b3dd2e369eb26cac">StateMachine</a> (ContextT *<a class="el" href="#a81352715cb482070745b3f7633f174a0">ctx</a>)</td></tr>
<tr class="memdesc:ab840087fe74ebea2b3dd2e369eb26cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ab840087fe74ebea2b3dd2e369eb26cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b7997f0afb4f2de360fb3c6442886" id="r_ac71b7997f0afb4f2de360fb3c6442886"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac71b7997f0afb4f2de360fb3c6442886">StateMachine</a> (const <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac71b7997f0afb4f2de360fb3c6442886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy construction.  <br /></td></tr>
<tr class="separator:ac71b7997f0afb4f2de360fb3c6442886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ebef78713bdc4a7e319dd3748e04ba" id="r_ac5ebef78713bdc4a7e319dd3748e04ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5ebef78713bdc4a7e319dd3748e04ba">operator=</a> (const <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac5ebef78713bdc4a7e319dd3748e04ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy assignment.  <br /></td></tr>
<tr class="separator:ac5ebef78713bdc4a7e319dd3748e04ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acd2fed5028e5fd97d13a38c141b7e0" id="r_a7acd2fed5028e5fd97d13a38c141b7e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7acd2fed5028e5fd97d13a38c141b7e0">~StateMachine</a> (void)</td></tr>
<tr class="memdesc:a7acd2fed5028e5fd97d13a38c141b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a7acd2fed5028e5fd97d13a38c141b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdd20578efd8a09906068692ddd39aa" id="r_a5bdd20578efd8a09906068692ddd39aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bdd20578efd8a09906068692ddd39aa">start</a> (void)</td></tr>
<tr class="memdesc:a5bdd20578efd8a09906068692ddd39aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the state machine.  <br /></td></tr>
<tr class="separator:a5bdd20578efd8a09906068692ddd39aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81352715cb482070745b3f7633f174a0" id="r_a81352715cb482070745b3f7633f174a0"><td class="memItemLeft" align="right" valign="top">ContextT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81352715cb482070745b3f7633f174a0">ctx</a> (void)</td></tr>
<tr class="memdesc:a81352715cb482070745b3f7633f174a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context object.  <br /></td></tr>
<tr class="separator:a81352715cb482070745b3f7633f174a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6d137b2f1ec65169986fa3cb28d226" id="r_a0b6d137b2f1ec65169986fa3cb28d226"><td class="memTemplParams" colspan="2">template&lt;class NewStateT &gt; </td></tr>
<tr class="memitem:a0b6d137b2f1ec65169986fa3cb28d226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b6d137b2f1ec65169986fa3cb28d226">setState</a> (NewStateT *<a class="el" href="#aa4b0bf23278eacb29ff7cc146c52f5fd">state</a>=new NewStateT)</td></tr>
<tr class="memdesc:a0b6d137b2f1ec65169986fa3cb28d226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to the given state.  <br /></td></tr>
<tr class="separator:a0b6d137b2f1ec65169986fa3cb28d226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa825020adb49f6da15a7706fcd998774" id="r_aa825020adb49f6da15a7706fcd998774"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa825020adb49f6da15a7706fcd998774"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa825020adb49f6da15a7706fcd998774">isActive</a> (void) const</td></tr>
<tr class="memdesc:aa825020adb49f6da15a7706fcd998774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given state is the active one.  <br /></td></tr>
<tr class="separator:aa825020adb49f6da15a7706fcd998774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b0bf23278eacb29ff7cc146c52f5fd" id="r_aa4b0bf23278eacb29ff7cc146c52f5fd"><td class="memItemLeft" align="right" valign="top">StateTopT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4b0bf23278eacb29ff7cc146c52f5fd">state</a> (void)</td></tr>
<tr class="memdesc:aa4b0bf23278eacb29ff7cc146c52f5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active state.  <br /></td></tr>
<tr class="separator:aa4b0bf23278eacb29ff7cc146c52f5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bd74de1a2649dc6744136e83b4b37a" id="r_af6bd74de1a2649dc6744136e83b4b37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6bd74de1a2649dc6744136e83b4b37a">setTimeout</a> (int timeout_ms)</td></tr>
<tr class="memdesc:af6bd74de1a2649dc6744136e83b4b37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout after which the timeoutEvent is issued.  <br /></td></tr>
<tr class="separator:af6bd74de1a2649dc6744136e83b4b37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05475fad4e9d8350a8831dcba1c8c1e5" id="r_a05475fad4e9d8350a8831dcba1c8c1e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05475fad4e9d8350a8831dcba1c8c1e5">setTimeoutAt</a> (struct tm &amp;tm, int expire_offset=0)</td></tr>
<tr class="memdesc:a05475fad4e9d8350a8831dcba1c8c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout after which the timeoutAtEvent is issued.  <br /></td></tr>
<tr class="separator:a05475fad4e9d8350a8831dcba1c8c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5383926909b7a65b7c0231f1d29ea" id="r_a39c5383926909b7a65b7c0231f1d29ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39c5383926909b7a65b7c0231f1d29ea">clearTimeout</a> (void)</td></tr>
<tr class="memdesc:a39c5383926909b7a65b7c0231f1d29ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a pending timeout.  <br /></td></tr>
<tr class="separator:a39c5383926909b7a65b7c0231f1d29ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14913c307f2cee1a600f94d4a4fa9c88" id="r_a14913c307f2cee1a600f94d4a4fa9c88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14913c307f2cee1a600f94d4a4fa9c88">clearTimeoutAt</a> (void)</td></tr>
<tr class="memdesc:a14913c307f2cee1a600f94d4a4fa9c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a pending absolute time timeout.  <br /></td></tr>
<tr class="separator:a14913c307f2cee1a600f94d4a4fa9c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ContextT, class StateTopT&gt;<br />
class Async::StateMachine&lt; ContextT, StateTopT &gt;</div><p>Implements a hierarchial state machine. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-03-19 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContextT</td><td>State machine context </td></tr>
    <tr><td class="paramname">StateTopT</td><td>The top state class</td></tr>
  </table>
  </dd>
</dl>
<p>A class that implements a Hierarchial Finite State Machine.</p>
<p>struct Context { Variables and functions used within the state machine }; struct StateTop : <a class="el" href="classAsync_1_1StateTopBase.html#aa66ff7f573158dadd76a0c391edaec30" title="A type alias to simplify declaration of the top state.">Async::StateTopBase&lt;Context, StateTop&gt;::Type</a> { static constexpr auto NAME = "Top"; Event functions implemented by states that handle them virtual void eventA(void) {} virtual void eventB(void) {} }; struct StateMyStateA : Async::StateBase&lt;StateTop, StateMyStateA&gt; { static constexpr auto NAME = "MyStateA"; Event handler functions virtual void eventA(void) override {} }; struct StateMyStateB : Async::StateBase&lt;StateTop, StateMyStateB&gt; { static constexpr auto NAME = "MyStateB"; Event handler functions virtual void eventB(void) override {} }; Context ctx; Async::StateMachine&lt;Context, StateTop&gt; sm(&amp;ctx); sm.start()</p>
<p>The NAME constant is only needed for state transition debugging. To enable debugging, define ASYNC_STATE_MACHINE_DEBUG before including this file.</p>
<p>Full example below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#define ASYNC_STATE_MACHINE_DEBUG</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Context</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop;</div>
<div class="line"><span class="keyword">struct </span>StateDisconnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedA;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedB;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop : <a class="code hl_class" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt;Context, StateTop&gt;::Type</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Top&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_function" href="classAsync_1_1StateTopBase.html#ad0240d817b81955d485b90215646e633">setState&lt;StateDisconnected&gt;</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> entry(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> exit(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateDisconnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateDisconnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Disconnected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::eventA: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    ctx().a = 24;</div>
<div class="line">    setState&lt;StateConnected&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateConnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Connected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedA&gt;();</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::eventB: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedB&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedA : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedA&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedA&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedB : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedB&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedB&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Context ctx;</div>
<div class="line">  ctx.a = 42;</div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1StateMachine.html">Async::StateMachine&lt;Context, StateTop&gt;</a> sm(&amp;ctx);</div>
<div class="line">  sm.start();</div>
<div class="line">  sm.state().eventA();</div>
<div class="line">  sm.state().eventB();</div>
<div class="line">  sm.setState&lt;StateDisconnected&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aAsyncStateMachine_8h_html"><div class="ttname"><a href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a></div><div class="ttdoc">A_brief_description_for_this_file.</div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html"><div class="ttname"><a href="classAsync_1_1StateBase.html">Async::StateBase</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00381">AsyncStateMachine.h:382</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_a400103160bb8dde0e4eca83424b6cc1b"><div class="ttname"><a href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">Async::StateBase::exit</a></div><div class="ttdeci">void exit(void)</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00466">AsyncStateMachine.h:466</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab27ec9eb5fec22d27615900aa9b8dcae"><div class="ttname"><a href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">Async::StateBase::entry</a></div><div class="ttdeci">void entry(void)</div><div class="ttdoc">Called when a state is entered.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00453">AsyncStateMachine.h:453</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab61d235fd1aad805e35523f6726f3491"><div class="ttname"><a href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">Async::StateBase::init</a></div><div class="ttdeci">void init(void)</div><div class="ttdoc">Called before a transition from one state to another.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00440">AsyncStateMachine.h:440</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateMachine_html"><div class="ttname"><a href="classAsync_1_1StateMachine.html">Async::StateMachine</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00156">AsyncStateMachine.h:157</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html"><div class="ttname"><a href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a></div><div class="ttdoc">The base class for the top state of a state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00513">AsyncStateMachine.h:514</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html_ad0240d817b81955d485b90215646e633"><div class="ttname"><a href="classAsync_1_1StateTopBase.html#ad0240d817b81955d485b90215646e633">Async::StateTopBase::setState</a></div><div class="ttdeci">void setState(void)</div><div class="ttdoc">Transition to the given state.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00549">AsyncStateMachine.h:549</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#_a6">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00156">156</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6d630fbcb20c6a17bb2de8deed8353f5" name="a6d630fbcb20c6a17bb2de8deed8353f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d630fbcb20c6a17bb2de8deed8353f5">&#9670;&#160;</a></span>StateTopBaseT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::StateTopBaseT = <a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a>&lt;ContextT,StateTopT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias simplifying access to the top state base type. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00162">162</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab840087fe74ebea2b3dd2e369eb26cac" name="ab840087fe74ebea2b3dd2e369eb26cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab840087fe74ebea2b3dd2e369eb26cac">&#9670;&#160;</a></span>StateMachine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::StateMachine </td>
          <td>(</td>
          <td class="paramtype">ContextT *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00168">168</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00332">Async::StateMachine&lt; ContextT, StateTopT &gt;::clearTimeout()</a>, <a class="el" href="AsyncStateMachine_8h_source.html#l00346">Async::StateMachine&lt; ContextT, StateTopT &gt;::clearTimeoutAt()</a>, <a class="el" href="AsyncAtTimer_8h_source.html#l00203">Async::AtTimer::expired</a>, and <a class="el" href="AsyncTimer_8h_source.html#l00210">Async::Timer::expired</a>.</p>

</div>
</div>
<a id="ac71b7997f0afb4f2de360fb3c6442886" name="ac71b7997f0afb4f2de360fb3c6442886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71b7997f0afb4f2de360fb3c6442886">&#9670;&#160;</a></span>StateMachine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::StateMachine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a>&lt; ContextT, StateTopT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow copy construction. </p>

</div>
</div>
<a id="a7acd2fed5028e5fd97d13a38c141b7e0" name="a7acd2fed5028e5fd97d13a38c141b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acd2fed5028e5fd97d13a38c141b7e0">&#9670;&#160;</a></span>~StateMachine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::~<a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a> </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00199">199</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a39c5383926909b7a65b7c0231f1d29ea" name="a39c5383926909b7a65b7c0231f1d29ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5383926909b7a65b7c0231f1d29ea">&#9670;&#160;</a></span>clearTimeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::clearTimeout </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a pending timeout. </p>
<p>Use this function to immediately cancel a running timeout timer. See <a class="el" href="#af6bd74de1a2649dc6744136e83b4b37a">setTimeout</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00332">332</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="classAsync_1_1Timer.html#ad2b6f5e24b9619c354e2ecf1e21241bc">Async::Timer::setEnable()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00581">Async::StateTopBase&lt; ContextT, TopStateT &gt;::clearTimeout()</a>, and <a class="el" href="AsyncStateMachine_8h_source.html#l00168">Async::StateMachine&lt; ContextT, StateTopT &gt;::StateMachine()</a>.</p>

</div>
</div>
<a id="a14913c307f2cee1a600f94d4a4fa9c88" name="a14913c307f2cee1a600f94d4a4fa9c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14913c307f2cee1a600f94d4a4fa9c88">&#9670;&#160;</a></span>clearTimeoutAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::clearTimeoutAt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a pending absolute time timeout. </p>
<p>Use this function to immediately cancel a running absolute time timeout timer. See <a class="el" href="#a05475fad4e9d8350a8831dcba1c8c1e5">setTimeoutAt</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00346">346</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="classAsync_1_1AtTimer.html#a9f3c8be47c471194e6979bcfc40806de">Async::AtTimer::stop()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00589">Async::StateTopBase&lt; ContextT, TopStateT &gt;::clearTimeoutAt()</a>, and <a class="el" href="AsyncStateMachine_8h_source.html#l00168">Async::StateMachine&lt; ContextT, StateTopT &gt;::StateMachine()</a>.</p>

</div>
</div>
<a id="a81352715cb482070745b3f7633f174a0" name="a81352715cb482070745b3f7633f174a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81352715cb482070745b3f7633f174a0">&#9670;&#160;</a></span>ctx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContextT &amp; <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::ctx </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the context object. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the context object </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00221">221</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00540">Async::StateTopBase&lt; ContextT, TopStateT &gt;::ctx()</a>.</p>

</div>
</div>
<a id="aa825020adb49f6da15a7706fcd998774" name="aa825020adb49f6da15a7706fcd998774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa825020adb49f6da15a7706fcd998774">&#9670;&#160;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::isActive </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given state is the active one. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if the given state is the active one</dd></dl>
<p>Use this function to check if the given state is the active one. The state to check is given as a template argument to the function. E.g.</p>
<p>if (<a class="el" href="#aa825020adb49f6da15a7706fcd998774" title="Check if the given state is the active one.">isActive&lt;NextState&gt;()</a>) {} </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00281">281</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="ac5ebef78713bdc4a7e319dd3748e04ba" name="ac5ebef78713bdc4a7e319dd3748e04ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ebef78713bdc4a7e319dd3748e04ba">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a> &amp; <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a>&lt; ContextT, StateTopT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow copy assignment. </p>

</div>
</div>
<a id="a0b6d137b2f1ec65169986fa3cb28d226" name="a0b6d137b2f1ec65169986fa3cb28d226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6d137b2f1ec65169986fa3cb28d226">&#9670;&#160;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<div class="memtemplate">
template&lt;class NewStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::setState </td>
          <td>(</td>
          <td class="paramtype">NewStateT *</td>          <td class="paramname"><span class="paramname"><em>state</em></span><span class="paramdefsep"> = </span><span class="paramdefval">new&#160;NewStateT</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch to the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>state object to switch to</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to switch to the given state. The state to switch to is best given as a template argument to the function. E.g.</p>
<p><a class="el" href="#a0b6d137b2f1ec65169986fa3cb28d226" title="Switch to the given state.">setState&lt;NextState&gt;()</a>;</p>
<p>NOTE: The state machine implementation cannot handle state switching loops right now. It's ok to set the same state as the current one since it will just be ignored. Switching to the current state via other states init functions, will cause an infinite loop. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00241">241</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00290">Async::StateMachine&lt; ContextT, StateTopT &gt;::state()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00549">Async::StateTopBase&lt; ContextT, TopStateT &gt;::setState()</a>, and <a class="el" href="AsyncStateMachine_8h_source.html#l00212">Async::StateMachine&lt; ContextT, StateTopT &gt;::start()</a>.</p>

</div>
</div>
<a id="af6bd74de1a2649dc6744136e83b4b37a" name="af6bd74de1a2649dc6744136e83b4b37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bd74de1a2649dc6744136e83b4b37a">&#9670;&#160;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::setTimeout </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout after which the timeoutEvent is issued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>The timeout value in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to set a timeout to occur after the specified number of milliseconds. The timeoutEvent will be issued after the time has expired. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00300">300</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="classAsync_1_1Timer.html#ad2b6f5e24b9619c354e2ecf1e21241bc">Async::Timer::setEnable()</a>, and <a class="el" href="classAsync_1_1Timer.html#a76f34ef1d8de22424ad46683dac07e8d">Async::Timer::setTimeout()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00559">Async::StateTopBase&lt; ContextT, TopStateT &gt;::setTimeout()</a>.</p>

</div>
</div>
<a id="a05475fad4e9d8350a8831dcba1c8c1e5" name="a05475fad4e9d8350a8831dcba1c8c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05475fad4e9d8350a8831dcba1c8c1e5">&#9670;&#160;</a></span>setTimeoutAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::setTimeoutAt </td>
          <td>(</td>
          <td class="paramtype">struct tm &amp;</td>          <td class="paramname"><span class="paramname"><em>tm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>expire_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout after which the timeoutAtEvent is issued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The absolute time when the timeout should occur </td></tr>
    <tr><td class="paramname">expire_offset</td><td>A millisecond offset for the timer expiration</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to set a timeout to occur at the specified absolute time, plus or minus the offset value. The time is specified in local time. The timeoutAtEvent will be issued after the time has expired. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00319">319</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="classAsync_1_1AtTimer.html#a63725e4ff5d1153228e2b148e4466d8d">Async::AtTimer::setExpireOffset()</a>, <a class="el" href="classAsync_1_1AtTimer.html#add10ffd9c611903e2c145319ee82f75e">Async::AtTimer::setTimeout()</a>, and <a class="el" href="classAsync_1_1AtTimer.html#a4e1c7fcca095b4b2182c6a6e2303550e">Async::AtTimer::start()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00570">Async::StateTopBase&lt; ContextT, TopStateT &gt;::setTimeoutAt()</a>.</p>

</div>
</div>
<a id="a5bdd20578efd8a09906068692ddd39aa" name="a5bdd20578efd8a09906068692ddd39aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdd20578efd8a09906068692ddd39aa">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::start </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the state machine. </p>
<p>This function must be called after constructing the state machine. The top state will be initialized and entered. Do not call any other functions in this class until this function has been called. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00212">212</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00241">Async::StateMachine&lt; ContextT, StateTopT &gt;::setState()</a>.</p>

</div>
</div>
<a id="aa4b0bf23278eacb29ff7cc146c52f5fd" name="aa4b0bf23278eacb29ff7cc146c52f5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b0bf23278eacb29ff7cc146c52f5fd">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class StateTopT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StateTopT &amp; <a class="el" href="classAsync_1_1StateMachine.html">Async::StateMachine</a>&lt; ContextT, StateTopT &gt;::state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the active state. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the active state </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00290">290</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00241">Async::StateMachine&lt; ContextT, StateTopT &gt;::setState()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
