<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::StateBase&lt; ParentT, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1StateBase.html">StateBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classAsync_1_1StateBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::StateBase&lt; ParentT, T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements a hierarchial state machine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Async::StateBase&lt; ParentT, T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAsync_1_1StateBase.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9daf4c4e3f5976714ebb7601f364d48b" id="r_a9daf4c4e3f5976714ebb7601f364d48b"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9daf4c4e3f5976714ebb7601f364d48b">typeId</a> (void) const override</td></tr>
<tr class="memdesc:a9daf4c4e3f5976714ebb7601f364d48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the typeid for this state.  <br /></td></tr>
<tr class="separator:a9daf4c4e3f5976714ebb7601f364d48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b9705853ffaf35db4a3e5c252b6cce" id="r_a11b9705853ffaf35db4a3e5c252b6cce"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b9705853ffaf35db4a3e5c252b6cce">name</a> (void) const</td></tr>
<tr class="separator:a11b9705853ffaf35db4a3e5c252b6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3f7b18acaa7feb7c65ca16d1a43d17a2" id="r_a3f7b18acaa7feb7c65ca16d1a43d17a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7b18acaa7feb7c65ca16d1a43d17a2">initHandler</a> (void) override</td></tr>
<tr class="memdesc:a3f7b18acaa7feb7c65ca16d1a43d17a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle calling the init function on state transitions.  <br /></td></tr>
<tr class="separator:a3f7b18acaa7feb7c65ca16d1a43d17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a63b7ee181f19b397e47577433d618" id="r_a75a63b7ee181f19b397e47577433d618"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a63b7ee181f19b397e47577433d618">entryHandler</a> (typename ParentT::StateT *from) override</td></tr>
<tr class="memdesc:a75a63b7ee181f19b397e47577433d618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle calling the entry function on state transitions.  <br /></td></tr>
<tr class="separator:a75a63b7ee181f19b397e47577433d618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10125c9fb4bd430b993d1a1f7ca0987a" id="r_a10125c9fb4bd430b993d1a1f7ca0987a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10125c9fb4bd430b993d1a1f7ca0987a">exitHandler</a> (typename ParentT::StateT *to) override</td></tr>
<tr class="memdesc:a10125c9fb4bd430b993d1a1f7ca0987a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle calling the exit function on state transitions.  <br /></td></tr>
<tr class="separator:a10125c9fb4bd430b993d1a1f7ca0987a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d235fd1aad805e35523f6726f3491" id="r_ab61d235fd1aad805e35523f6726f3491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab61d235fd1aad805e35523f6726f3491">init</a> (void)</td></tr>
<tr class="memdesc:ab61d235fd1aad805e35523f6726f3491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a transition from one state to another.  <br /></td></tr>
<tr class="separator:ab61d235fd1aad805e35523f6726f3491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ec9eb5fec22d27615900aa9b8dcae" id="r_ab27ec9eb5fec22d27615900aa9b8dcae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a> (void)</td></tr>
<tr class="memdesc:ab27ec9eb5fec22d27615900aa9b8dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a state is entered.  <br /></td></tr>
<tr class="separator:ab27ec9eb5fec22d27615900aa9b8dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400103160bb8dde0e4eca83424b6cc1b" id="r_a400103160bb8dde0e4eca83424b6cc1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400103160bb8dde0e4eca83424b6cc1b">exit</a> (void)</td></tr>
<tr class="separator:a400103160bb8dde0e4eca83424b6cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2765f6dfb1b5f253c7ca43709e8159f4" id="r_a2765f6dfb1b5f253c7ca43709e8159f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2765f6dfb1b5f253c7ca43709e8159f4">timeoutEvent</a> (void) override</td></tr>
<tr class="memdesc:a2765f6dfb1b5f253c7ca43709e8159f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event function that will be called when a timeout occurs.  <br /></td></tr>
<tr class="separator:a2765f6dfb1b5f253c7ca43709e8159f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adb0cfb1b8c7b41dcb838694a47398b" id="r_a4adb0cfb1b8c7b41dcb838694a47398b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4adb0cfb1b8c7b41dcb838694a47398b">timeoutAtEvent</a> (void) override</td></tr>
<tr class="separator:a4adb0cfb1b8c7b41dcb838694a47398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ParentT, class T&gt;<br />
class Async::StateBase&lt; ParentT, T &gt;</div><p>Implements a hierarchial state machine. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-03-19 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ParentT</td><td>The parent state </td></tr>
    <tr><td class="paramname">T</td><td>The state class itself</td></tr>
  </table>
  </dd>
</dl>
<p>This class should be used together with <a class="el" href="classAsync_1_1StateMachine.html" title="Implements a hierarchial state machine.">Async::StateMachine</a> to form a state in the state machine. All states must inherit from this class.</p>
<p>struct StateMyState : Async::StateBase&lt;StateTop, StateMyState&gt; { static constexpr auto NAME = "MyState"; };</p>
<p>The NAME constant is only needed for state transition debugging.</p>
<p>Full example below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#define ASYNC_STATE_MACHINE_DEBUG</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Context</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop;</div>
<div class="line"><span class="keyword">struct </span>StateDisconnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedA;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedB;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop : <a class="code hl_class" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt;Context, StateTop&gt;::Type</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Top&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_function" href="classAsync_1_1StateTopBase.html#ad0240d817b81955d485b90215646e633">setState&lt;StateDisconnected&gt;</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> entry(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> exit(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateDisconnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateDisconnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Disconnected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::eventA: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    ctx().a = 24;</div>
<div class="line">    setState&lt;StateConnected&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateConnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Connected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedA&gt;();</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::eventB: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedB&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedA : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedA&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedA&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedB : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedB&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedB&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Context ctx;</div>
<div class="line">  ctx.a = 42;</div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1StateMachine.html">Async::StateMachine&lt;Context, StateTop&gt;</a> sm(&amp;ctx);</div>
<div class="line">  sm.start();</div>
<div class="line">  sm.state().eventA();</div>
<div class="line">  sm.state().eventB();</div>
<div class="line">  sm.setState&lt;StateDisconnected&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aAsyncStateMachine_8h_html"><div class="ttname"><a href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a></div><div class="ttdoc">A_brief_description_for_this_file.</div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html"><div class="ttname"><a href="classAsync_1_1StateBase.html">Async::StateBase</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00381">AsyncStateMachine.h:382</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_a400103160bb8dde0e4eca83424b6cc1b"><div class="ttname"><a href="#a400103160bb8dde0e4eca83424b6cc1b">Async::StateBase::exit</a></div><div class="ttdeci">void exit(void)</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00466">AsyncStateMachine.h:466</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab27ec9eb5fec22d27615900aa9b8dcae"><div class="ttname"><a href="#ab27ec9eb5fec22d27615900aa9b8dcae">Async::StateBase::entry</a></div><div class="ttdeci">void entry(void)</div><div class="ttdoc">Called when a state is entered.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00453">AsyncStateMachine.h:453</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab61d235fd1aad805e35523f6726f3491"><div class="ttname"><a href="#ab61d235fd1aad805e35523f6726f3491">Async::StateBase::init</a></div><div class="ttdeci">void init(void)</div><div class="ttdoc">Called before a transition from one state to another.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00440">AsyncStateMachine.h:440</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateMachine_html"><div class="ttname"><a href="classAsync_1_1StateMachine.html">Async::StateMachine</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00156">AsyncStateMachine.h:157</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html"><div class="ttname"><a href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a></div><div class="ttdoc">The base class for the top state of a state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00513">AsyncStateMachine.h:514</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html_ad0240d817b81955d485b90215646e633"><div class="ttname"><a href="classAsync_1_1StateTopBase.html#ad0240d817b81955d485b90215646e633">Async::StateTopBase::setState</a></div><div class="ttdeci">void setState(void)</div><div class="ttdoc">Transition to the given state.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00549">AsyncStateMachine.h:549</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#_a2">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00381">381</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab27ec9eb5fec22d27615900aa9b8dcae" name="ab27ec9eb5fec22d27615900aa9b8dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27ec9eb5fec22d27615900aa9b8dcae">&#9670;&#160;</a></span>entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a state is entered. </p>
<p>The entry function is called when a state is entered. It is not allowed to initiate any state transitions in this function. That should be done in the init function or in event handlers.</p>
<p>The entry function will be called, from top to bottom, for all states in the hierarchy. States that are common to the source and the target states will not have the entry function called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#a4">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00453">453</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00408">Async::StateBase&lt; ParentT, T &gt;::entryHandler()</a>.</p>

</div>
</div>
<a id="a75a63b7ee181f19b397e47577433d618" name="a75a63b7ee181f19b397e47577433d618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a63b7ee181f19b397e47577433d618">&#9670;&#160;</a></span>entryHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::entryHandler </td>
          <td>(</td>
          <td class="paramtype">typename ParentT::StateT *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle calling the entry function on state transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The state that we transition from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00408">408</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00453">Async::StateBase&lt; ParentT, T &gt;::entry()</a>.</p>

</div>
</div>
<a id="a400103160bb8dde0e4eca83424b6cc1b" name="a400103160bb8dde0e4eca83424b6cc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400103160bb8dde0e4eca83424b6cc1b">&#9670;&#160;</a></span>exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::exit </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@bief Called when a state is exited</p>
<p>The exit function is called when a state is exited. It is not allowed to initiate any state transitions in this function. That should be done in the init function or in event handlers.</p>
<p>The exit function will be called, from bottom to top, for all states in the hierarchy. States that are common to the source and the target states will not have the exit function called. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#a5">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00466">466</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00421">Async::StateBase&lt; ParentT, T &gt;::exitHandler()</a>.</p>

</div>
</div>
<a id="a10125c9fb4bd430b993d1a1f7ca0987a" name="a10125c9fb4bd430b993d1a1f7ca0987a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10125c9fb4bd430b993d1a1f7ca0987a">&#9670;&#160;</a></span>exitHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::exitHandler </td>
          <td>(</td>
          <td class="paramtype">typename ParentT::StateT *</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle calling the exit function on state transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The state that we transition to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00421">421</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00466">Async::StateBase&lt; ParentT, T &gt;::exit()</a>.</p>

</div>
</div>
<a id="ab61d235fd1aad805e35523f6726f3491" name="ab61d235fd1aad805e35523f6726f3491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61d235fd1aad805e35523f6726f3491">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a transition from one state to another. </p>
<p>The init function is called before a state transition is executed so this is the place to switch to another state using the setState function. That is typically used to select a substate to activate when a state is activated.</p>
<p>The init function will only be called in the specific target state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#a3">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00440">440</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsyncStateMachine_8h_source.html#l00399">Async::StateBase&lt; ParentT, T &gt;::initHandler()</a>.</p>

</div>
</div>
<a id="a3f7b18acaa7feb7c65ca16d1a43d17a2" name="a3f7b18acaa7feb7c65ca16d1a43d17a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7b18acaa7feb7c65ca16d1a43d17a2">&#9670;&#160;</a></span>initHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::initHandler </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle calling the init function on state transitions. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00399">399</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00440">Async::StateBase&lt; ParentT, T &gt;::init()</a>.</p>

</div>
</div>
<a id="a11b9705853ffaf35db4a3e5c252b6cce" name="a11b9705853ffaf35db4a3e5c252b6cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b9705853ffaf35db4a3e5c252b6cce">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::name </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00393">393</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="a4adb0cfb1b8c7b41dcb838694a47398b" name="a4adb0cfb1b8c7b41dcb838694a47398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adb0cfb1b8c7b41dcb838694a47398b">&#9670;&#160;</a></span>timeoutAtEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::timeoutAtEvent </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00484">484</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="a2765f6dfb1b5f253c7ca43709e8159f4" name="a2765f6dfb1b5f253c7ca43709e8159f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2765f6dfb1b5f253c7ca43709e8159f4">&#9670;&#160;</a></span>timeoutEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::timeoutEvent </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An event function that will be called when a timeout occurs. </p>
<p>This event function will be called when a timeout, previously set up using the setTimeout function, has occurred.</p>
<p>As all event functions this is a virtual function which work like any other virtual function in C++. The state which is furtherest down in the hierarchy, which have the timeoutEvent function implemented, will have the function called. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00479">479</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="a9daf4c4e3f5976714ebb7601f364d48b" name="a9daf4c4e3f5976714ebb7601f364d48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daf4c4e3f5976714ebb7601f364d48b">&#9670;&#160;</a></span>typeId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParentT , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info &amp; <a class="el" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt; ParentT, T &gt;::typeId </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the typeid for this state. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the typeid for this state </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00388">388</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
