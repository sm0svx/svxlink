<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::EncryptedUdpSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1EncryptedUdpSocket.html">EncryptedUdpSocket</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classAsync_1_1EncryptedUdpSocket-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::EncryptedUdpSocket Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for sending encrypted UDP datagrams.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Async::EncryptedUdpSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAsync_1_1EncryptedUdpSocket.png" usemap="#Async::EncryptedUdpSocket_map" alt=""/>
  <map id="Async::EncryptedUdpSocket_map" name="Async::EncryptedUdpSocket_map">
<area href="classAsync_1_1UdpSocket.html" title="A class for working with UDP sockets." alt="Async::UdpSocket" shape="rect" coords="0,56,172,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af0ce203f4418f2c9590d1de636c2ed9d" id="r_af0ce203f4418f2c9590d1de636c2ed9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> = EVP_CIPHER</td></tr>
<tr class="separator:af0ce203f4418f2c9590d1de636c2ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab973ce540b79a87624a4878ace4cf76" id="r_aab973ce540b79a87624a4878ace4cf76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab973ce540b79a87624a4878ace4cf76">EncryptedUdpSocket</a> (uint16_t local_port=0, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;bind_ip=<a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a>())</td></tr>
<tr class="memdesc:aab973ce540b79a87624a4878ace4cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aab973ce540b79a87624a4878ace4cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ef49c72a6f93fb8f2ee70e8b29b78c" id="r_a13ef49c72a6f93fb8f2ee70e8b29b78c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13ef49c72a6f93fb8f2ee70e8b29b78c">~EncryptedUdpSocket</a> (void) override</td></tr>
<tr class="memdesc:a13ef49c72a6f93fb8f2ee70e8b29b78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy construction.  <br /></td></tr>
<tr class="separator:a13ef49c72a6f93fb8f2ee70e8b29b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8579d4d8c701baa750573d97d141a1af" id="r_a8579d4d8c701baa750573d97d141a1af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8579d4d8c701baa750573d97d141a1af">initOk</a> (void) const override</td></tr>
<tr class="memdesc:a8579d4d8c701baa750573d97d141a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the initialization was ok.  <br /></td></tr>
<tr class="separator:a8579d4d8c701baa750573d97d141a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc39d86df5b7c8183e2eaf56fdfe733" id="r_a9bc39d86df5b7c8183e2eaf56fdfe733"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc39d86df5b7c8183e2eaf56fdfe733">setCipher</a> (const std::string &amp;type)</td></tr>
<tr class="memdesc:a9bc39d86df5b7c8183e2eaf56fdfe733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which cipher algorithm type to use.  <br /></td></tr>
<tr class="separator:a9bc39d86df5b7c8183e2eaf56fdfe733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f0a9a444cf03f3479fda6cb8f9cf57" id="r_a73f0a9a444cf03f3479fda6cb8f9cf57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f0a9a444cf03f3479fda6cb8f9cf57">setCipher</a> (const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *cipher)</td></tr>
<tr class="memdesc:a73f0a9a444cf03f3479fda6cb8f9cf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which cipher algorithm type to use.  <br /></td></tr>
<tr class="separator:a73f0a9a444cf03f3479fda6cb8f9cf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d9b1c5be95a45cb488cb4569faa7c" id="r_ab60d9b1c5be95a45cb488cb4569faa7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab60d9b1c5be95a45cb488cb4569faa7c">setCipherIV</a> (std::vector&lt; uint8_t &gt; iv)</td></tr>
<tr class="memdesc:ab60d9b1c5be95a45cb488cb4569faa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initialization vector to use with the cipher.  <br /></td></tr>
<tr class="separator:ab60d9b1c5be95a45cb488cb4569faa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d3eddc2afabbf99fd0882de948589d" id="r_a32d3eddc2afabbf99fd0882de948589d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32d3eddc2afabbf99fd0882de948589d">cipherIV</a> (void) const</td></tr>
<tr class="memdesc:a32d3eddc2afabbf99fd0882de948589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a previously set initialization vector (IV)  <br /></td></tr>
<tr class="separator:a32d3eddc2afabbf99fd0882de948589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22488a8501c51f1b724689840dca2c1" id="r_ad22488a8501c51f1b724689840dca2c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22488a8501c51f1b724689840dca2c1">setCipherKey</a> (std::vector&lt; uint8_t &gt; key)</td></tr>
<tr class="memdesc:ad22488a8501c51f1b724689840dca2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cipher key to use.  <br /></td></tr>
<tr class="separator:ad22488a8501c51f1b724689840dca2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab461b3ea51ed4bd3bf895ce55a76309a" id="r_ab461b3ea51ed4bd3bf895ce55a76309a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab461b3ea51ed4bd3bf895ce55a76309a">setCipherKey</a> (void)</td></tr>
<tr class="memdesc:ab461b3ea51ed4bd3bf895ce55a76309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a random cipher key to use.  <br /></td></tr>
<tr class="separator:ab461b3ea51ed4bd3bf895ce55a76309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1620b80ec0b9ccbead30d1517b3b15d" id="r_af1620b80ec0b9ccbead30d1517b3b15d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1620b80ec0b9ccbead30d1517b3b15d">cipherKey</a> (void) const</td></tr>
<tr class="memdesc:af1620b80ec0b9ccbead30d1517b3b15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently set cipher key.  <br /></td></tr>
<tr class="separator:af1620b80ec0b9ccbead30d1517b3b15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa384dd93dfc83f868401ca8e653b6630" id="r_aa384dd93dfc83f868401ca8e653b6630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa384dd93dfc83f868401ca8e653b6630">setTagLength</a> (int taglen)</td></tr>
<tr class="memdesc:aa384dd93dfc83f868401ca8e653b6630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length of the AEAD tag.  <br /></td></tr>
<tr class="separator:aa384dd93dfc83f868401ca8e653b6630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe1ffd748bba6771f270134539e831" id="r_abdfe1ffd748bba6771f270134539e831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdfe1ffd748bba6771f270134539e831">tagLength</a> (void) const</td></tr>
<tr class="memdesc:abdfe1ffd748bba6771f270134539e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently set up tag length.  <br /></td></tr>
<tr class="separator:abdfe1ffd748bba6771f270134539e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2428e55065d0818f3b44540a06d6ac77" id="r_a2428e55065d0818f3b44540a06d6ac77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2428e55065d0818f3b44540a06d6ac77">setCipherAADLength</a> (int aadlen)</td></tr>
<tr class="memdesc:a2428e55065d0818f3b44540a06d6ac77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length of the associated data for AEAD ciphers.  <br /></td></tr>
<tr class="separator:a2428e55065d0818f3b44540a06d6ac77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cac7a49c54c60fa240579e9b4d7a6" id="r_ad12cac7a49c54c60fa240579e9b4d7a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12cac7a49c54c60fa240579e9b4d7a6">cipherAADLength</a> (void) const</td></tr>
<tr class="memdesc:ad12cac7a49c54c60fa240579e9b4d7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently set up length of the additional associated data.  <br /></td></tr>
<tr class="separator:ad12cac7a49c54c60fa240579e9b4d7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af9e75bbe9952034a27a7a5de141863" id="r_a8af9e75bbe9952034a27a7a5de141863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8af9e75bbe9952034a27a7a5de141863">write</a> (const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;remote_ip, int remote_port, const void *buf, int count) override</td></tr>
<tr class="memdesc:a8af9e75bbe9952034a27a7a5de141863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the remote host.  <br /></td></tr>
<tr class="separator:a8af9e75bbe9952034a27a7a5de141863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2761c81e98d6430cb5fb82eb1407b131" id="r_a2761c81e98d6430cb5fb82eb1407b131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2761c81e98d6430cb5fb82eb1407b131">write</a> (const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;remote_ip, int remote_port, const void *aad, int aadlen, const void *buf, int cnt)</td></tr>
<tr class="memdesc:a2761c81e98d6430cb5fb82eb1407b131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the remote host.  <br /></td></tr>
<tr class="separator:a2761c81e98d6430cb5fb82eb1407b131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAsync_1_1UdpSocket"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classAsync_1_1UdpSocket')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAsync_1_1UdpSocket.html">Async::UdpSocket</a></td></tr>
<tr class="memitem:ac7f62db0012c61cb474599db53bcb997 inherit pub_methods_classAsync_1_1UdpSocket" id="r_ac7f62db0012c61cb474599db53bcb997"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#ac7f62db0012c61cb474599db53bcb997">UdpSocket</a> (uint16_t local_port=0, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;bind_ip=<a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a>())</td></tr>
<tr class="memdesc:ac7f62db0012c61cb474599db53bcb997 inherit pub_methods_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ac7f62db0012c61cb474599db53bcb997 inherit pub_methods_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00570e4b5301455315efa54995f21fae inherit pub_methods_classAsync_1_1UdpSocket" id="r_a00570e4b5301455315efa54995f21fae"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#a00570e4b5301455315efa54995f21fae">~UdpSocket</a> (void)</td></tr>
<tr class="memdesc:a00570e4b5301455315efa54995f21fae inherit pub_methods_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a00570e4b5301455315efa54995f21fae inherit pub_methods_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510119c358ff5de36e92f9a172a137cd inherit pub_methods_classAsync_1_1UdpSocket" id="r_a510119c358ff5de36e92f9a172a137cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAsync_1_1IpAddress.html">Async::IpAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#a510119c358ff5de36e92f9a172a137cd">localAddr</a> (void) const</td></tr>
<tr class="memdesc:a510119c358ff5de36e92f9a172a137cd inherit pub_methods_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address associated with this connection.  <br /></td></tr>
<tr class="separator:a510119c358ff5de36e92f9a172a137cd inherit pub_methods_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ada9b47b8f53e1815215367ffaf2a0 inherit pub_methods_classAsync_1_1UdpSocket" id="r_a29ada9b47b8f53e1815215367ffaf2a0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#a29ada9b47b8f53e1815215367ffaf2a0">localPort</a> (void) const</td></tr>
<tr class="memdesc:a29ada9b47b8f53e1815215367ffaf2a0 inherit pub_methods_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local UDP port associated with this connection.  <br /></td></tr>
<tr class="separator:a29ada9b47b8f53e1815215367ffaf2a0 inherit pub_methods_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb3de8ed0333f0074cbbfdef06587d2 inherit pub_methods_classAsync_1_1UdpSocket" id="r_a7bb3de8ed0333f0074cbbfdef06587d2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#a7bb3de8ed0333f0074cbbfdef06587d2">fd</a> (void) const</td></tr>
<tr class="memdesc:a7bb3de8ed0333f0074cbbfdef06587d2 inherit pub_methods_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file descriptor for the UDP socket.  <br /></td></tr>
<tr class="separator:a7bb3de8ed0333f0074cbbfdef06587d2 inherit pub_methods_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab553e0babbbaa5f0bc05997a941c198e" id="r_ab553e0babbbaa5f0bc05997a941c198e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab553e0babbbaa5f0bc05997a941c198e">fetchCipher</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab553e0babbbaa5f0bc05997a941c198e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a named cipher object.  <br /></td></tr>
<tr class="separator:ab553e0babbbaa5f0bc05997a941c198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba443baceea7a3be2ba073c2d7886fb" id="r_abba443baceea7a3be2ba073c2d7886fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba443baceea7a3be2ba073c2d7886fb">freeCipher</a> (<a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *cipher)</td></tr>
<tr class="memdesc:abba443baceea7a3be2ba073c2d7886fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory for a previously allocated cipher object.  <br /></td></tr>
<tr class="separator:abba443baceea7a3be2ba073c2d7886fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f271928c3b28fe8b9ddc1346c1df102" id="r_a3f271928c3b28fe8b9ddc1346c1df102"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f271928c3b28fe8b9ddc1346c1df102">cipherName</a> (const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *cipher)</td></tr>
<tr class="memdesc:a3f271928c3b28fe8b9ddc1346c1df102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a cipher from a cipher object.  <br /></td></tr>
<tr class="separator:a3f271928c3b28fe8b9ddc1346c1df102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a6b80660f3a3436a485ea0fbfd9ef8" id="r_ae5a6b80660f3a3436a485ea0fbfd9ef8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5a6b80660f3a3436a485ea0fbfd9ef8">randomBytes</a> (std::vector&lt; uint8_t &gt; &amp;bytes)</td></tr>
<tr class="memdesc:ae5a6b80660f3a3436a485ea0fbfd9ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a vector with random bytes.  <br /></td></tr>
<tr class="separator:ae5a6b80660f3a3436a485ea0fbfd9ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae3403ba0ab56b5b7a4f894cae947c8b8" id="r_ae3403ba0ab56b5b7a4f894cae947c8b8"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; bool, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;, uint16_t, void *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3403ba0ab56b5b7a4f894cae947c8b8">cipherDataReceived</a></td></tr>
<tr class="memdesc:ae3403ba0ab56b5b7a4f894cae947c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when cipher data has been received.  <br /></td></tr>
<tr class="separator:ae3403ba0ab56b5b7a4f894cae947c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f5f6aa2a6e85a366ea896591030713" id="r_a18f5f6aa2a6e85a366ea896591030713"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;, uint16_t, void *, void *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18f5f6aa2a6e85a366ea896591030713">dataReceived</a></td></tr>
<tr class="memdesc:a18f5f6aa2a6e85a366ea896591030713"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when cipher data has been decrypted.  <br /></td></tr>
<tr class="separator:a18f5f6aa2a6e85a366ea896591030713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classAsync_1_1UdpSocket"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_classAsync_1_1UdpSocket')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classAsync_1_1UdpSocket.html">Async::UdpSocket</a></td></tr>
<tr class="memitem:abe52a040db33723f08e11778a417ef24 inherit pub_attribs_classAsync_1_1UdpSocket" id="r_abe52a040db33723f08e11778a417ef24"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;, uint16_t, void *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#abe52a040db33723f08e11778a417ef24">dataReceived</a></td></tr>
<tr class="memdesc:abe52a040db33723f08e11778a417ef24 inherit pub_attribs_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when data has been received.  <br /></td></tr>
<tr class="separator:abe52a040db33723f08e11778a417ef24 inherit pub_attribs_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a99aac6688acc25ff8e307c5f0fe61 inherit pub_attribs_classAsync_1_1UdpSocket" id="r_aa0a99aac6688acc25ff8e307c5f0fe61"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1UdpSocket.html#aa0a99aac6688acc25ff8e307c5f0fe61">sendBufferFull</a></td></tr>
<tr class="memdesc:aa0a99aac6688acc25ff8e307c5f0fe61 inherit pub_attribs_classAsync_1_1UdpSocket"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the send buffer is full.  <br /></td></tr>
<tr class="separator:aa0a99aac6688acc25ff8e307c5f0fe61 inherit pub_attribs_classAsync_1_1UdpSocket"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5c2369597eef8f404847eaf33f760339" id="r_a5c2369597eef8f404847eaf33f760339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c2369597eef8f404847eaf33f760339">onDataReceived</a> (const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;ip, uint16_t port, void *buf, int count) override</td></tr>
<tr class="separator:a5c2369597eef8f404847eaf33f760339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classAsync_1_1UdpSocket"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classAsync_1_1UdpSocket')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAsync_1_1UdpSocket.html">Async::UdpSocket</a></td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for sending encrypted UDP datagrams. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2023-07-23</dd></dl>
<p>Use this class to create a UDP socket that is used for sending and receiving encrypted UDP datagrams. The available ciphers are the block ciphers provided by the OpenSSL library, e.g. AES-128-GCM.</p>
<div class="fragment"></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00121">121</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af0ce203f4418f2c9590d1de636c2ed9d" name="af0ce203f4418f2c9590d1de636c2ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ce203f4418f2c9590d1de636c2ed9d">&#9670;&#160;</a></span>Cipher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Async::EncryptedUdpSocket::Cipher</a> = EVP_CIPHER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00124">124</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab973ce540b79a87624a4878ace4cf76" name="aab973ce540b79a87624a4878ace4cf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab973ce540b79a87624a4878ace4cf76">&#9670;&#160;</a></span>EncryptedUdpSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Async::EncryptedUdpSocket::EncryptedUdpSocket </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>local_port</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bind_ip</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_port</td><td>The local UDP port to bind to, 0=ephemeral </td></tr>
    <tr><td class="paramname">bind_ip</td><td>The local interface (IP) to bind to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ef49c72a6f93fb8f2ee70e8b29b78c" name="a13ef49c72a6f93fb8f2ee70e8b29b78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ef49c72a6f93fb8f2ee70e8b29b78c">&#9670;&#160;</a></span>~EncryptedUdpSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Async::EncryptedUdpSocket::~EncryptedUdpSocket </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow copy construction. </p>
<p>Disallow copy assignment</p>
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad12cac7a49c54c60fa240579e9b4d7a6" name="ad12cac7a49c54c60fa240579e9b4d7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cac7a49c54c60fa240579e9b4d7a6">&#9670;&#160;</a></span>cipherAADLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Async::EncryptedUdpSocket::cipherAADLength </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently set up length of the additional associated data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the length of the associated data </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00302">302</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<a id="a32d3eddc2afabbf99fd0882de948589d" name="a32d3eddc2afabbf99fd0882de948589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d3eddc2afabbf99fd0882de948589d">&#9670;&#160;</a></span>cipherIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; uint8_t &gt; Async::EncryptedUdpSocket::cipherIV </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a previously set initialization vector (IV) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the IV or an empty vector if not set </dd></dl>

</div>
</div>
<a id="af1620b80ec0b9ccbead30d1517b3b15d" name="af1620b80ec0b9ccbead30d1517b3b15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1620b80ec0b9ccbead30d1517b3b15d">&#9670;&#160;</a></span>cipherKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; uint8_t &gt; Async::EncryptedUdpSocket::cipherKey </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently set cipher key. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the key or an empty vector if the key is not set </dd></dl>

</div>
</div>
<a id="a3f271928c3b28fe8b9ddc1346c1df102" name="a3f271928c3b28fe8b9ddc1346c1df102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f271928c3b28fe8b9ddc1346c1df102">&#9670;&#160;</a></span>cipherName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string Async::EncryptedUdpSocket::cipherName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *</td>          <td class="paramname"><span class="paramname"><em>cipher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of a cipher from a cipher object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>The cipher object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the cipher </dd></dl>

</div>
</div>
<a id="ab553e0babbbaa5f0bc05997a941c198e" name="ab553e0babbbaa5f0bc05997a941c198e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab553e0babbbaa5f0bc05997a941c198e">&#9670;&#160;</a></span>fetchCipher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> * Async::EncryptedUdpSocket::fetchCipher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch a named cipher object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the cipher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to a cipher object</dd></dl>
<p>Use this function to fetch a cipher object using its name, e.g. AES-128-GCM. The returned object must be freed using the freeCipher function if not used with the setCipher function. If the setCipher function has been used, the object does not have to be freed. </p>

</div>
</div>
<a id="abba443baceea7a3be2ba073c2d7886fb" name="abba443baceea7a3be2ba073c2d7886fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba443baceea7a3be2ba073c2d7886fb">&#9670;&#160;</a></span>freeCipher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Async::EncryptedUdpSocket::freeCipher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *</td>          <td class="paramname"><span class="paramname"><em>cipher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free memory for a previously allocated cipher object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>The cipher object to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8579d4d8c701baa750573d97d141a1af" name="a8579d4d8c701baa750573d97d141a1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8579d4d8c701baa750573d97d141a1af">&#9670;&#160;</a></span>initOk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::initOk </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the initialization was ok. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if everything went fine during initialization or <em>false</em> if something went wrong</dd></dl>
<p>This function should always be called after constructing the object to see if everything went fine. </p>

<p>Reimplemented from <a class="el" href="classAsync_1_1UdpSocket.html#aef41844f3f54eb6f908ee69d0f0e6ee8">Async::UdpSocket</a>.</p>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00195">195</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncUdpSocket_8h_source.html#l00149">Async::UdpSocket::initOk()</a>.</p>

</div>
</div>
<a id="a5c2369597eef8f404847eaf33f760339" name="a5c2369597eef8f404847eaf33f760339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2369597eef8f404847eaf33f760339">&#9670;&#160;</a></span>onDataReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Async::EncryptedUdpSocket::onDataReceived </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classAsync_1_1UdpSocket.html#af48ad669faa93b05d91646d5242b650b">Async::UdpSocket</a>.</p>

</div>
</div>
<a id="ae5a6b80660f3a3436a485ea0fbfd9ef8" name="ae5a6b80660f3a3436a485ea0fbfd9ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a6b80660f3a3436a485ea0fbfd9ef8">&#9670;&#160;</a></span>randomBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Async::EncryptedUdpSocket::randomBytes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a vector with random bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The vector to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success</dd></dl>
<p>This function will fill the given vector with random bytes. Set the vector size to the number of bytes that should be generated. A zero length vector is valid and will always return true. A cryptographically secure pseudo random generator (CSPRNG) is used to generate the bytes. </p>

</div>
</div>
<a id="a73f0a9a444cf03f3479fda6cb8f9cf57" name="a73f0a9a444cf03f3479fda6cb8f9cf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f0a9a444cf03f3479fda6cb8f9cf57">&#9670;&#160;</a></span>setCipher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::setCipher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af0ce203f4418f2c9590d1de636c2ed9d">Cipher</a> *</td>          <td class="paramname"><span class="paramname"><em>cipher</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set which cipher algorithm type to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>A pre-created cipher object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <em>true</em> on success</dd></dl>
<p>The setCipher function must be called before sending or receiving any datagrams. Use this function to set which block cipher algorithm to use. </p>

</div>
</div>
<a id="a9bc39d86df5b7c8183e2eaf56fdfe733" name="a9bc39d86df5b7c8183e2eaf56fdfe733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc39d86df5b7c8183e2eaf56fdfe733">&#9670;&#160;</a></span>setCipher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::setCipher </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set which cipher algorithm type to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The algorithm type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <em>true</em> on success</dd></dl>
<p>This function must be called before sending or receiving any datagrams. Use this function to set which block cipher algorithm to use, e.g. AES-128-GCM, ChaCha20, NULL. </p>

</div>
</div>
<a id="a2428e55065d0818f3b44540a06d6ac77" name="a2428e55065d0818f3b44540a06d6ac77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2428e55065d0818f3b44540a06d6ac77">&#9670;&#160;</a></span>setCipherAADLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Async::EncryptedUdpSocket::setCipherAADLength </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aadlen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the length of the associated data for AEAD ciphers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aadlen</td><td>The length of the additional associated data</td></tr>
  </table>
  </dd>
</dl>
<p>Some ciphers, like AES-128-GCM, support AEAD (Authenticated Encryption with Associated Data). A tag is then sent with the encrypted data to authenticate the sender of the data. Associated data, which is not encypted, can be sent along with the encrypted data. The associated data will be protected by the authentication present in AEAD ciphers if a tag is sent along with the encrypted data (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa384dd93dfc83f868401ca8e653b6630" title="Set the length of the AEAD tag.">setTagLength</a>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00296">296</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<a id="ab60d9b1c5be95a45cb488cb4569faa7c" name="ab60d9b1c5be95a45cb488cb4569faa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60d9b1c5be95a45cb488cb4569faa7c">&#9670;&#160;</a></span>setCipherIV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::setCipherIV </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>iv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initialization vector to use with the cipher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iv</td><td>The initialization vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success</dd></dl>
<p>This function will set the initialization vector (IV) to use with the selected cipher. Different ciphers require different IVs. Find and read the requirements for a specific cipher for constructing a safe IV. The setCipher function must be called before calling this function. </p>

</div>
</div>
<a id="ad22488a8501c51f1b724689840dca2c1" name="ad22488a8501c51f1b724689840dca2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22488a8501c51f1b724689840dca2c1">&#9670;&#160;</a></span>setCipherKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::setCipherKey </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cipher key to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The cipher key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success</dd></dl>
<p>This function will set the key to use with the selected cipher. Different ciphers require different keys. Find and read the requirements for a specific cipher for constructing a key. The setCipher function must be called before calling this function. </p>

</div>
</div>
<a id="ab461b3ea51ed4bd3bf895ce55a76309a" name="ab461b3ea51ed4bd3bf895ce55a76309a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab461b3ea51ed4bd3bf895ce55a76309a">&#9670;&#160;</a></span>setCipherKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::setCipherKey </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a random cipher key to use. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success</dd></dl>
<p>This function will set a random key to use with the selected cipher. A cryptographically secure pseudo random generator (CSPRNG) is used to generate the key. The setCipher function must be called before calling this function. </p>

</div>
</div>
<a id="aa384dd93dfc83f868401ca8e653b6630" name="aa384dd93dfc83f868401ca8e653b6630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa384dd93dfc83f868401ca8e653b6630">&#9670;&#160;</a></span>setTagLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Async::EncryptedUdpSocket::setTagLength </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>taglen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the length of the AEAD tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taglen</td><td>The length of the tag in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Some ciphers, like AES-128-GCM, support AEAD (Authenticated Encryption with Associated Data). A tag is then sent with the encrypted data to authenticate the sender of the data. The tag can have differing lengths for different applications and different levels of security. </p>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00277">277</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<a id="abdfe1ffd748bba6771f270134539e831" name="abdfe1ffd748bba6771f270134539e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfe1ffd748bba6771f270134539e831">&#9670;&#160;</a></span>tagLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Async::EncryptedUdpSocket::tagLength </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently set up tag length. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the tag length </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00283">283</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<a id="a2761c81e98d6430cb5fb82eb1407b131" name="a2761c81e98d6430cb5fb82eb1407b131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2761c81e98d6430cb5fb82eb1407b131">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remote_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>remote_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>aad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aadlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_ip</td><td>The IP-address of the remote host </td></tr>
    <tr><td class="paramname">remote_port</td><td>The remote port to use </td></tr>
    <tr><td class="paramname">aad</td><td>Prepended unencrypted data </td></tr>
    <tr><td class="paramname">buf</td><td>A buffer containing the data to send </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <em>true</em> on success or <em>false</em> on failure </dd></dl>

</div>
</div>
<a id="a8af9e75bbe9952034a27a7a5de141863" name="a8af9e75bbe9952034a27a7a5de141863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af9e75bbe9952034a27a7a5de141863">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::EncryptedUdpSocket::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remote_ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>remote_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_ip</td><td>The IP-address of the remote host </td></tr>
    <tr><td class="paramname">remote_port</td><td>The remote port to use </td></tr>
    <tr><td class="paramname">buf</td><td>A buffer containing the data to send </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <em>true</em> on success or <em>false</em> on failure </dd></dl>

<p>Reimplemented from <a class="el" href="classAsync_1_1UdpSocket.html#a65afb24200d2c81b9e82b116628d8e69">Async::UdpSocket</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae3403ba0ab56b5b7a4f894cae947c8b8" name="ae3403ba0ab56b5b7a4f894cae947c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3403ba0ab56b5b7a4f894cae947c8b8">&#9670;&#160;</a></span>cipherDataReceived</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;bool, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a>&amp;, uint16_t, void*, int&gt; Async::EncryptedUdpSocket::cipherDataReceived</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when cipher data has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP-address the data was received from </td></tr>
    <tr><td class="paramname">port</td><td>The remote port number </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer containing the read cipher data </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes read </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00335">335</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<a id="a18f5f6aa2a6e85a366ea896591030713" name="a18f5f6aa2a6e85a366ea896591030713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f5f6aa2a6e85a366ea896591030713">&#9670;&#160;</a></span>dataReceived</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, const <a class="el" href="classAsync_1_1IpAddress.html">IpAddress</a>&amp;, uint16_t, void*, void*, int&gt; Async::EncryptedUdpSocket::dataReceived</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when cipher data has been decrypted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The IP-address the data was received from </td></tr>
    <tr><td class="paramname">port</td><td>The remote port number </td></tr>
    <tr><td class="paramname">aad</td><td>Additional Associated Data </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer containing the read data </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes read </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html#l00346">346</a> of file <a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncEncryptedUdpSocket_8h_source.html">AsyncEncryptedUdpSocket.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
