<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: AsyncFactory_demo.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div class="header">
  <div class="headertitle"><div class="title">AsyncFactory_demo.cpp</div></div>
</div><!--header-->
<div class="contents">
<p>Base class for an object factory.</p>
<p>Base class for an object factory </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The baseclass </td></tr>
    <tr><td class="paramname">Args</td><td>Contructor arguments, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2020-07-21</dd></dl>
<p>This class implements the actual factory. The type of the factory class would be something like Async::Factory&lt;Animal&gt; for a base class representing animals. It is most often adviced to create a typedef to represent the type of the factory, e.g.:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a id="_a0" name="_a0"></a><a class="code hl_class" href="classAsync_1_1Factory.html">Async::Factory&lt;Animal&gt;</a> AnimalFactory;</div>
<div class="ttc" id="aclassAsync_1_1Factory_html"><div class="ttname"><a href="classAsync_1_1Factory.html">Async::Factory</a></div><div class="ttdef"><b>Definition</b> <a href="AsyncFactory_8h_source.html#l00148">AsyncFactory.h:149</a></div></div>
</div><!-- fragment --><p>Creating a typedef bocomes incresingly convenient when the constructor of the objects being manufactured take one or more arguments since the type definition will become quite long.</p>
<p>Also the addition of a convenience function for creating objects make the usage of the factory easier and more readable. This function make use of the typedef declared above and also rely on that a convenience struct for the specific factories have been declared as described for <a class="el" href="classAsync_1_1SpecificFactory.html">Async::SpecificFactory</a>.</p>
<div class="fragment"><div class="line">Animal* createAnimal(<span class="keyword">const</span> std::string&amp; obj_name)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Dog&gt; dog_factory;</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Cat&gt; cat_factory;</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Fox&gt; fox_factory;</div>
<div class="line">  <span class="keywordflow">return</span> AnimalFactory::createNamedObject(obj_name);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following example will describe in more detail how to use the factory classes.</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This example demonstrates how to use the Async::Factory classes to enable a</span></div>
<div class="line"><span class="comment">// class being created using the factory pattern.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The scenario is that we have a base class, Animal, which specific animal</span></div>
<div class="line"><span class="comment">// classes derive from, e.g. Dog, Cat etc. Each animal have a given name which</span></div>
<div class="line"><span class="comment">// is stored in the base class. That name is given to the constructor of each</span></div>
<div class="line"><span class="comment">// animal which demonstrates how to use the Async::Factory class with</span></div>
<div class="line"><span class="comment">// constructors that take one or more arguments. This is made possible by the</span></div>
<div class="line"><span class="comment">// fact that the Async::Factory classes use variadic templates.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The base class also have a pure virtual function, &quot;say&quot;, that each derived</span></div>
<div class="line"><span class="comment">// class must implement. It should return a string describing what the specific</span></div>
<div class="line"><span class="comment">// animal say.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Just before main() a number of convenience constructs; a typedef, a</span></div>
<div class="line"><span class="comment">// templated struct and a function, have been added to make using the</span></div>
<div class="line"><span class="comment">// Async::Factory easier. These would normally go into the same files as where</span></div>
<div class="line"><span class="comment">// the base class is declared.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncFactory_8h.html">AsyncFactory.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The base class for all animals. This class has no connection to the</span></div>
<div class="line">  <span class="comment">// Async::Factory classes.</span></div>
<div class="line"><span class="keyword">class </span>Animal</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Animal(<span class="keyword">const</span> std::string&amp; given_name) : m_given_name(given_name) {}</div>
<div class="line">    <span class="keyword">virtual</span> ~Animal(<span class="keywordtype">void</span>) {}</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; givenName(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_given_name; }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* say(<span class="keywordtype">void</span>) <span class="keyword">const</span> = 0;</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    std::string m_given_name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A class representing a dog. The OBJNAME constant is needed to make the</span></div>
<div class="line">  <span class="comment">// convenience classas defined below work.</span></div>
<div class="line"><span class="keyword">struct </span>Dog : <span class="keyword">public</span> Animal</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> OBJNAME = <span class="stringliteral">&quot;dog&quot;</span>;</div>
<div class="line">  Dog(<span class="keyword">const</span> std::string&amp; given_name) : Animal(given_name) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* say(<span class="keywordtype">void</span>)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;Voff&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A class representing a cat. The OBJNAME constant is needed to make the</span></div>
<div class="line">  <span class="comment">// convenience classas defined below work.</span></div>
<div class="line"><span class="keyword">struct </span>Cat : <span class="keyword">public</span> Animal</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> OBJNAME = <span class="stringliteral">&quot;cat&quot;</span>;</div>
<div class="line">  Cat(<span class="keyword">const</span> std::string&amp; given_name) : Animal(given_name) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* say(<span class="keywordtype">void</span>)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;Meow&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A class representing a fox. The OBJNAME constant is needed to make the</span></div>
<div class="line">  <span class="comment">// convenience classas defined below work.</span></div>
<div class="line"><span class="keyword">struct </span>Fox : <span class="keyword">public</span> Animal</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> OBJNAME = <span class="stringliteral">&quot;fox&quot;</span>;</div>
<div class="line">  Fox(<span class="keyword">const</span> std::string&amp; given_name) : Animal(given_name) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* say(<span class="keywordtype">void</span>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Ding, ding, ding, ding, ding, di-ding, di-ding&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add a custom animal, in this case a cow. This animal is not part of the</span></div>
<div class="line">  <span class="comment">// &quot;core animals&quot; but instead it is added just before calling createAnimal.</span></div>
<div class="line"><span class="keyword">struct </span>Cow : <span class="keyword">public</span> Animal</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> OBJNAME = <span class="stringliteral">&quot;cow&quot;</span>;</div>
<div class="line">  Cow(<span class="keyword">const</span> std::string&amp; given_name) : Animal(given_name) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* say(<span class="keywordtype">void</span>)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Moooo&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A convenience struct to make instantiation of spcecific animals easier.</span></div>
<div class="line">  <span class="comment">// This class relies on the fact that each specific animal class have</span></div>
<div class="line">  <span class="comment">// declared a constant, OBJNAME. That constant specify the name for the class</span></div>
<div class="line">  <span class="comment">// that is used when using the factory to create objects.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>AnimalSpecificFactory</div>
<div class="line">  : <span class="keyword">public</span> <a id="_a0" name="_a0"></a><a class="code hl_class" href="classAsync_1_1SpecificFactory.html">Async::SpecificFactory</a>&lt;Animal, T, std::string&gt;</div>
<div class="line">{</div>
<div class="line">  AnimalSpecificFactory(<span class="keywordtype">void</span>)</div>
<div class="line">    : <a class="code hl_namespace" href="namespaceAsync.html">Async</a>::SpecificFactory&lt;Animal, T, std::string&gt;(T::OBJNAME) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A convenience typedef to make access to Async::Factory members easier.</span></div>
<div class="line"><span class="keyword">using </span>AnimalFactory = <a class="code hl_class" href="classAsync_1_1Factory.html">Async::Factory&lt;Animal, std::string&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// A function for creating an animal</span></div>
<div class="line">std::unique_ptr&lt;Animal&gt; createAnimal(<span class="keyword">const</span> std::string&amp; obj_name,</div>
<div class="line">                                     <span class="keyword">const</span> std::string&amp; animal_name)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Dog&gt; dog_factory;</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Cat&gt; cat_factory;</div>
<div class="line">  <span class="keyword">static</span> AnimalSpecificFactory&lt;Fox&gt; fox_factory;</div>
<div class="line">  <span class="keywordflow">return</span> std::unique_ptr&lt;Animal&gt;(</div>
<div class="line">      AnimalFactory::createNamedObject(obj_name, animal_name));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (argc &lt; 3)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;obj name&gt; &lt;given name&gt;&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">const</span> std::string obj_name(argv[1]);</div>
<div class="line">  <span class="keyword">const</span> std::string given_name(argv[2]);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add our custom animal before calling createAnimal</span></div>
<div class="line">  AnimalSpecificFactory&lt;Cow&gt; cow_factory;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the animal specified on the command line</span></div>
<div class="line">  <span class="keyword">auto</span> obj = createAnimal(obj_name, given_name);</div>
<div class="line">  <span class="keywordflow">if</span> (obj == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, but there is no animal \&quot;&quot;</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">&quot;\&quot; :-(&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Valid animals: &quot;</span> &lt;&lt; AnimalFactory::validFactories()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    exit(1);</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;- Hello, &quot;</span> &lt;&lt; obj-&gt;givenName() &lt;&lt; <span class="stringliteral">&quot;! What do you say?\n- &quot;</span></div>
<div class="line">            &lt;&lt; obj-&gt;say() &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aAsyncFactory_8h_html"><div class="ttname"><a href="AsyncFactory_8h.html">AsyncFactory.h</a></div><div class="ttdoc">Some templates used to support the creation of an object factory.</div></div>
<div class="ttc" id="aclassAsync_1_1SpecificFactory_html"><div class="ttname"><a href="classAsync_1_1SpecificFactory.html">Async::SpecificFactory</a></div><div class="ttdef"><b>Definition</b> <a href="AsyncFactory_8h_source.html#l00290">AsyncFactory.h:291</a></div></div>
<div class="ttc" id="anamespaceAsync_html"><div class="ttname"><a href="namespaceAsync.html">Async</a></div><div class="ttdoc">Namespace for the asynchronous programming classes.</div><div class="ttdef"><b>Definition</b> <a href="AsyncApplication_8h_source.html#l00075">AsyncApplication.h:76</a></div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
