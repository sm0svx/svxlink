<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::StateTopBase&lt; ContextT, TopStateT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classAsync_1_1StateTopBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::StateTopBase&lt; ContextT, TopStateT &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The base class for the top state of a state machine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa66ff7f573158dadd76a0c391edaec30" id="r_aa66ff7f573158dadd76a0c391edaec30"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa66ff7f573158dadd76a0c391edaec30">Type</a> = <a class="el" href="classAsync_1_1StateBase.html">StateBase</a>&lt;<a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a>&lt;ContextT, TopStateT&gt;, TopStateT&gt;</td></tr>
<tr class="memdesc:aa66ff7f573158dadd76a0c391edaec30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias to simplify declaration of the top state.  <br /></td></tr>
<tr class="separator:aa66ff7f573158dadd76a0c391edaec30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673f196118959a16b4a35b27036790b1" id="r_a673f196118959a16b4a35b27036790b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a> = TopStateT</td></tr>
<tr class="memdesc:a673f196118959a16b4a35b27036790b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias to access the top state type.  <br /></td></tr>
<tr class="separator:a673f196118959a16b4a35b27036790b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242aac8f5e327ed072d614785867c06" id="r_a8242aac8f5e327ed072d614785867c06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8242aac8f5e327ed072d614785867c06">StateMachineT</a> = <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a>&lt;ContextT, <a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a>&gt;</td></tr>
<tr class="memdesc:a8242aac8f5e327ed072d614785867c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias to simplify usage of the state machine type.  <br /></td></tr>
<tr class="separator:a8242aac8f5e327ed072d614785867c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4a968385c0a7bf0423bd60a36e8d420" id="r_ab4a968385c0a7bf0423bd60a36e8d420"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a968385c0a7bf0423bd60a36e8d420">~StateTopBase</a> (void)</td></tr>
<tr class="memdesc:ab4a968385c0a7bf0423bd60a36e8d420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ab4a968385c0a7bf0423bd60a36e8d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8af6a8f30033aea92377565baab0df" id="r_a8b8af6a8f30033aea92377565baab0df"><td class="memItemLeft" align="right" valign="top">ContextT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8af6a8f30033aea92377565baab0df">ctx</a> (void)</td></tr>
<tr class="memdesc:a8b8af6a8f30033aea92377565baab0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context object.  <br /></td></tr>
<tr class="separator:a8b8af6a8f30033aea92377565baab0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad0240d817b81955d485b90215646e633" id="r_ad0240d817b81955d485b90215646e633"><td class="memTemplParams" colspan="2">template&lt;class NewStateT &gt; </td></tr>
<tr class="memitem:ad0240d817b81955d485b90215646e633"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0240d817b81955d485b90215646e633">setState</a> (void)</td></tr>
<tr class="memdesc:ad0240d817b81955d485b90215646e633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition to the given state.  <br /></td></tr>
<tr class="separator:ad0240d817b81955d485b90215646e633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0ffcb252edcaf8633ad23e689253f5" id="r_a7b0ffcb252edcaf8633ad23e689253f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0ffcb252edcaf8633ad23e689253f5">setTimeout</a> (int timeout_ms)</td></tr>
<tr class="memdesc:a7b0ffcb252edcaf8633ad23e689253f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout after which the timeoutEvent is issued.  <br /></td></tr>
<tr class="separator:a7b0ffcb252edcaf8633ad23e689253f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e45e3a9c7e40af8db71bba706920d" id="r_a0b7e45e3a9c7e40af8db71bba706920d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7e45e3a9c7e40af8db71bba706920d">setTimeoutAt</a> (struct tm &amp;tm, int expire_offset=0)</td></tr>
<tr class="memdesc:a0b7e45e3a9c7e40af8db71bba706920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout after which the timeoutAtEvent is issued.  <br /></td></tr>
<tr class="separator:a0b7e45e3a9c7e40af8db71bba706920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f3bbbf308a9f19aba3c86e4a57f25d" id="r_ae0f3bbbf308a9f19aba3c86e4a57f25d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0f3bbbf308a9f19aba3c86e4a57f25d">clearTimeout</a> (void)</td></tr>
<tr class="memdesc:ae0f3bbbf308a9f19aba3c86e4a57f25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a pending timeout.  <br /></td></tr>
<tr class="separator:ae0f3bbbf308a9f19aba3c86e4a57f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c226a6a01282a804bc58ad0b3036cc" id="r_ad0c226a6a01282a804bc58ad0b3036cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c226a6a01282a804bc58ad0b3036cc">clearTimeoutAt</a> (void)</td></tr>
<tr class="memdesc:ad0c226a6a01282a804bc58ad0b3036cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a pending absolute time timeout.  <br /></td></tr>
<tr class="separator:ad0c226a6a01282a804bc58ad0b3036cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d9f7c1b91b972fbffbd1baccf3c1c1" id="r_a88d9f7c1b91b972fbffbd1baccf3c1c1"><td class="memItemLeft" align="right" valign="top">virtual const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d9f7c1b91b972fbffbd1baccf3c1c1">typeId</a> (void) const =0</td></tr>
<tr class="memdesc:a88d9f7c1b91b972fbffbd1baccf3c1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the typeid for this state.  <br /></td></tr>
<tr class="separator:a88d9f7c1b91b972fbffbd1baccf3c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82fef0e3c17d0a9fb6739d8d0e231dc" id="r_ad82fef0e3c17d0a9fb6739d8d0e231dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82fef0e3c17d0a9fb6739d8d0e231dc">initHandler</a> (void)=0</td></tr>
<tr class="memdesc:ad82fef0e3c17d0a9fb6739d8d0e231dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the init functon in a state.  <br /></td></tr>
<tr class="separator:ad82fef0e3c17d0a9fb6739d8d0e231dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de8487c9416617ff83d1e3b8674ff73" id="r_a0de8487c9416617ff83d1e3b8674ff73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de8487c9416617ff83d1e3b8674ff73">entryHandler</a> (<a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a> *from)</td></tr>
<tr class="memdesc:a0de8487c9416617ff83d1e3b8674ff73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all entry handlers in the state hierarchy, top to bottom.  <br /></td></tr>
<tr class="separator:a0de8487c9416617ff83d1e3b8674ff73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279ecf3927039b089be9e8080e534128" id="r_a279ecf3927039b089be9e8080e534128"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279ecf3927039b089be9e8080e534128">exitHandler</a> (<a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a> *to)</td></tr>
<tr class="memdesc:a279ecf3927039b089be9e8080e534128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all exit handlers in the state hierarchy, bottom to top.  <br /></td></tr>
<tr class="separator:a279ecf3927039b089be9e8080e534128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f62afe5f6579a87f1af4ed06815b553" id="r_a7f62afe5f6579a87f1af4ed06815b553"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f62afe5f6579a87f1af4ed06815b553">timeoutEvent</a> (void)=0</td></tr>
<tr class="memdesc:a7f62afe5f6579a87f1af4ed06815b553"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event function that will be called when a timeout occurs.  <br /></td></tr>
<tr class="separator:a7f62afe5f6579a87f1af4ed06815b553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783797b14439f1ddc8f659f5d759fbab" id="r_a783797b14439f1ddc8f659f5d759fbab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a783797b14439f1ddc8f659f5d759fbab">timeoutAtEvent</a> (void)=0</td></tr>
<tr class="memdesc:a783797b14439f1ddc8f659f5d759fbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event function called when an absolute time timeout occurs.  <br /></td></tr>
<tr class="separator:a783797b14439f1ddc8f659f5d759fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class ContextT, class TopStateT&gt;<br />
class Async::StateTopBase&lt; ContextT, TopStateT &gt;</div><p>The base class for the top state of a state machine. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2022-03-19</dd></dl>
<p>This class should be used together with <a class="el" href="classAsync_1_1StateMachine.html" title="Implements a hierarchial state machine.">Async::StateMachine</a> to form the top state of the state machine. The top state must use this class as its parent state. A type alias is available to simplify the syntax. E.g.</p>
<p>struct StateTop : <a class="el" href="#aa66ff7f573158dadd76a0c391edaec30" title="A type alias to simplify declaration of the top state.">Async::StateTopBase&lt;Context, StateTop&gt;::Type</a> { static constexpr auto NAME = "Top"; };</p>
<p>The NAME constant is only needed for state transition debugging.</p>
<p>Full demo below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#define ASYNC_STATE_MACHINE_DEBUG</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Context</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop;</div>
<div class="line"><span class="keyword">struct </span>StateDisconnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnected;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedA;</div>
<div class="line"><span class="keyword">struct </span>StateConnectedB;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateTop : <a class="code hl_class" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt;Context, StateTop&gt;::Type</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Top&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_function" href="#ad0240d817b81955d485b90215646e633">setState&lt;StateDisconnected&gt;</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> entry(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> exit(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateTop::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>) {}</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateDisconnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateDisconnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Disconnected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventA(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateDisconnected::eventA: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    ctx().a = 24;</div>
<div class="line">    setState&lt;StateConnected&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnected : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateTop, StateConnected&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;Connected&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedA&gt;();</div>
<div class="line">    <span class="comment">//setState&lt;StateDisconnected&gt;();</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> eventB(<span class="keywordtype">void</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnected::eventB: ctx.a=&quot;</span></div>
<div class="line">      &lt;&lt; ctx().a &lt;&lt; std::endl;</div>
<div class="line">    setState&lt;StateConnectedB&gt;();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedA : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedA&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedA&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">init</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::init&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedA::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StateConnectedB : <a class="code hl_class" href="classAsync_1_1StateBase.html">Async::StateBase</a>&lt;StateConnected, StateConnectedB&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="stringliteral">&quot;ConnectedB&quot;</span>;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">entry</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::entry&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">exit</a>(<span class="keywordtype">void</span>)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;### StateConnectedB::exit&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Context ctx;</div>
<div class="line">  ctx.a = 42;</div>
<div class="line">  <a class="code hl_class" href="classAsync_1_1StateMachine.html">Async::StateMachine&lt;Context, StateTop&gt;</a> sm(&amp;ctx);</div>
<div class="line">  sm.start();</div>
<div class="line">  sm.state().eventA();</div>
<div class="line">  sm.state().eventB();</div>
<div class="line">  sm.setState&lt;StateDisconnected&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aAsyncStateMachine_8h_html"><div class="ttname"><a href="AsyncStateMachine_8h.html">AsyncStateMachine.h</a></div><div class="ttdoc">A_brief_description_for_this_file.</div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html"><div class="ttname"><a href="classAsync_1_1StateBase.html">Async::StateBase</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00381">AsyncStateMachine.h:382</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_a400103160bb8dde0e4eca83424b6cc1b"><div class="ttname"><a href="classAsync_1_1StateBase.html#a400103160bb8dde0e4eca83424b6cc1b">Async::StateBase::exit</a></div><div class="ttdeci">void exit(void)</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00466">AsyncStateMachine.h:466</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab27ec9eb5fec22d27615900aa9b8dcae"><div class="ttname"><a href="classAsync_1_1StateBase.html#ab27ec9eb5fec22d27615900aa9b8dcae">Async::StateBase::entry</a></div><div class="ttdeci">void entry(void)</div><div class="ttdoc">Called when a state is entered.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00453">AsyncStateMachine.h:453</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateBase_html_ab61d235fd1aad805e35523f6726f3491"><div class="ttname"><a href="classAsync_1_1StateBase.html#ab61d235fd1aad805e35523f6726f3491">Async::StateBase::init</a></div><div class="ttdeci">void init(void)</div><div class="ttdoc">Called before a transition from one state to another.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00440">AsyncStateMachine.h:440</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateMachine_html"><div class="ttname"><a href="classAsync_1_1StateMachine.html">Async::StateMachine</a></div><div class="ttdoc">Implements a hierarchial state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00156">AsyncStateMachine.h:157</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html"><div class="ttname"><a href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a></div><div class="ttdoc">The base class for the top state of a state machine.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00513">AsyncStateMachine.h:514</a></div></div>
<div class="ttc" id="aclassAsync_1_1StateTopBase_html_ad0240d817b81955d485b90215646e633"><div class="ttname"><a href="#ad0240d817b81955d485b90215646e633">Async::StateTopBase::setState</a></div><div class="ttdeci">void setState(void)</div><div class="ttdoc">Transition to the given state.</div><div class="ttdef"><b>Definition</b> <a href="AsyncStateMachine_8h_source.html#l00549">AsyncStateMachine.h:549</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#_a0">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00513">513</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8242aac8f5e327ed072d614785867c06" name="a8242aac8f5e327ed072d614785867c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242aac8f5e327ed072d614785867c06">&#9670;&#160;</a></span>StateMachineT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::StateMachineT = <a class="el" href="classAsync_1_1StateMachine.html">StateMachine</a>&lt;ContextT, <a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias to simplify usage of the state machine type. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00529">529</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="a673f196118959a16b4a35b27036790b1" name="a673f196118959a16b4a35b27036790b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673f196118959a16b4a35b27036790b1">&#9670;&#160;</a></span>StateT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::StateT = TopStateT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias to access the top state type. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00524">524</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="aa66ff7f573158dadd76a0c391edaec30" name="aa66ff7f573158dadd76a0c391edaec30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66ff7f573158dadd76a0c391edaec30">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::Type = <a class="el" href="classAsync_1_1StateBase.html">StateBase</a>&lt;<a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a>&lt;ContextT, TopStateT&gt;, TopStateT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias to simplify declaration of the top state. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00519">519</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab4a968385c0a7bf0423bd60a36e8d420" name="ab4a968385c0a7bf0423bd60a36e8d420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a968385c0a7bf0423bd60a36e8d420">&#9670;&#160;</a></span>~StateTopBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::~<a class="el" href="classAsync_1_1StateTopBase.html">StateTopBase</a> </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00534">534</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae0f3bbbf308a9f19aba3c86e4a57f25d" name="ae0f3bbbf308a9f19aba3c86e4a57f25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f3bbbf308a9f19aba3c86e4a57f25d">&#9670;&#160;</a></span>clearTimeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::clearTimeout </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a pending timeout. </p>
<p>Use this function to immediately cancel a running timeout timer. See <a class="el" href="#a7b0ffcb252edcaf8633ad23e689253f5">setTimeout</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00581">581</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00332">Async::StateMachine&lt; ContextT, StateTopT &gt;::clearTimeout()</a>.</p>

</div>
</div>
<a id="ad0c226a6a01282a804bc58ad0b3036cc" name="ad0c226a6a01282a804bc58ad0b3036cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c226a6a01282a804bc58ad0b3036cc">&#9670;&#160;</a></span>clearTimeoutAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::clearTimeoutAt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a pending absolute time timeout. </p>
<p>Use this function to immediately cancel a running absolute time timeout timer. See <a class="el" href="#a0b7e45e3a9c7e40af8db71bba706920d">setTimeoutAt</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00589">589</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00346">Async::StateMachine&lt; ContextT, StateTopT &gt;::clearTimeoutAt()</a>.</p>

</div>
</div>
<a id="a8b8af6a8f30033aea92377565baab0df" name="a8b8af6a8f30033aea92377565baab0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8af6a8f30033aea92377565baab0df">&#9670;&#160;</a></span>ctx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContextT &amp; <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::ctx </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the context object. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the context object </dd></dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00540">540</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00221">Async::StateMachine&lt; ContextT, StateTopT &gt;::ctx()</a>.</p>

</div>
</div>
<a id="a0de8487c9416617ff83d1e3b8674ff73" name="a0de8487c9416617ff83d1e3b8674ff73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de8487c9416617ff83d1e3b8674ff73">&#9670;&#160;</a></span>entryHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::entryHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a> *</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all entry handlers in the state hierarchy, top to bottom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The state that we transition from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00605">605</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="a279ecf3927039b089be9e8080e534128" name="a279ecf3927039b089be9e8080e534128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279ecf3927039b089be9e8080e534128">&#9670;&#160;</a></span>exitHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::exitHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a673f196118959a16b4a35b27036790b1">StateT</a> *</td>          <td class="paramname"><span class="paramname"><em>to</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all exit handlers in the state hierarchy, bottom to top. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The state that we transition to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00611">611</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

</div>
</div>
<a id="ad82fef0e3c17d0a9fb6739d8d0e231dc" name="ad82fef0e3c17d0a9fb6739d8d0e231dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82fef0e3c17d0a9fb6739d8d0e231dc">&#9670;&#160;</a></span>initHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::initHandler </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the init functon in a state. </p>

</div>
</div>
<a id="ad0240d817b81955d485b90215646e633" name="ad0240d817b81955d485b90215646e633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0240d817b81955d485b90215646e633">&#9670;&#160;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<div class="memtemplate">
template&lt;class NewStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::setState </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transition to the given state. </p>
<p>See <a class="el" href="classAsync_1_1StateMachine.html#a0b6d137b2f1ec65169986fa3cb28d226">Async::StateMachine::setState</a>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AsyncStateMachine_demo_8cpp-example.html#a1">AsyncStateMachine_demo.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00549">549</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00241">Async::StateMachine&lt; ContextT, StateTopT &gt;::setState()</a>.</p>

</div>
</div>
<a id="a7b0ffcb252edcaf8633ad23e689253f5" name="a7b0ffcb252edcaf8633ad23e689253f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0ffcb252edcaf8633ad23e689253f5">&#9670;&#160;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::setTimeout </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout after which the timeoutEvent is issued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>The timeout value in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to set a timeout to occur after the specified number of milliseconds. The timeoutEvent will be issued after the time has expired. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00559">559</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00300">Async::StateMachine&lt; ContextT, StateTopT &gt;::setTimeout()</a>.</p>

</div>
</div>
<a id="a0b7e45e3a9c7e40af8db71bba706920d" name="a0b7e45e3a9c7e40af8db71bba706920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7e45e3a9c7e40af8db71bba706920d">&#9670;&#160;</a></span>setTimeoutAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::setTimeoutAt </td>
          <td>(</td>
          <td class="paramtype">struct tm &amp;</td>          <td class="paramname"><span class="paramname"><em>tm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>expire_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a timeout after which the timeoutAtEvent is issued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>The absolute time when the timeout should occur </td></tr>
    <tr><td class="paramname">expire_offset</td><td>A millisecond offset for the timer expiration</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to set a timeout to occur at the specified absolute time, plus or minus the offset value. The time is specified in local time. The timeoutAtEvent will be issued after the time has expired. </p>

<p class="definition">Definition at line <a class="el" href="AsyncStateMachine_8h_source.html#l00570">570</a> of file <a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a>.</p>

<p class="reference">References <a class="el" href="AsyncStateMachine_8h_source.html#l00319">Async::StateMachine&lt; ContextT, StateTopT &gt;::setTimeoutAt()</a>.</p>

</div>
</div>
<a id="a783797b14439f1ddc8f659f5d759fbab" name="a783797b14439f1ddc8f659f5d759fbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783797b14439f1ddc8f659f5d759fbab">&#9670;&#160;</a></span>timeoutAtEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::timeoutAtEvent </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event function called when an absolute time timeout occurs. </p>
<p>This event function will be called when an absolute time timeout, previously set up using the setTimeoutAt function, has occurred.</p>
<p>As all event functions this is a virtual function which work like any other virtual function in C++. The state which is furtherest down in the hierarchy, which have the timeoutAtEvent function implemented, will have the function called. </p>

</div>
</div>
<a id="a7f62afe5f6579a87f1af4ed06815b553" name="a7f62afe5f6579a87f1af4ed06815b553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f62afe5f6579a87f1af4ed06815b553">&#9670;&#160;</a></span>timeoutEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::timeoutEvent </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An event function that will be called when a timeout occurs. </p>
<p>This event function will be called when a timeout, previously set up using the setTimeout function, has occurred.</p>
<p>As all event functions this is a virtual function which work like any other virtual function in C++. The state which is furtherest down in the hierarchy, which have the timeoutEvent function implemented, will have the function called. </p>

</div>
</div>
<a id="a88d9f7c1b91b972fbffbd1baccf3c1c1" name="a88d9f7c1b91b972fbffbd1baccf3c1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d9f7c1b91b972fbffbd1baccf3c1c1">&#9670;&#160;</a></span>typeId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextT , class TopStateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::type_info &amp; <a class="el" href="classAsync_1_1StateTopBase.html">Async::StateTopBase</a>&lt; ContextT, TopStateT &gt;::typeId </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the typeid for this state. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncStateMachine_8h_source.html">AsyncStateMachine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
