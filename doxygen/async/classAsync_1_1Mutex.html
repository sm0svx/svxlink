<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async: Async::Mutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Async<span id="projectnumber">&#160;1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1Mutex.html">Mutex</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAsync_1_1Mutex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Async::Mutex Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Synchronize execution from a thread with the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncMutex_8h_source.html">AsyncMutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51117fdd230652796c40cac6d1cafacf" id="r_a51117fdd230652796c40cac6d1cafacf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51117fdd230652796c40cac6d1cafacf">Mutex</a> (void) noexcept</td></tr>
<tr class="memdesc:a51117fdd230652796c40cac6d1cafacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a51117fdd230652796c40cac6d1cafacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490beb71934a5bc879027ea4c64ffe3c" id="r_a490beb71934a5bc879027ea4c64ffe3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a490beb71934a5bc879027ea4c64ffe3c">Mutex</a> (const <a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp;)=delete</td></tr>
<tr class="memdesc:a490beb71934a5bc879027ea4c64ffe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deleted.  <br /></td></tr>
<tr class="separator:a490beb71934a5bc879027ea4c64ffe3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a0dfb9fec945b66e14eeb5d7681702" id="r_a66a0dfb9fec945b66e14eeb5d7681702"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a0dfb9fec945b66e14eeb5d7681702">~Mutex</a> (void)</td></tr>
<tr class="memdesc:a66a0dfb9fec945b66e14eeb5d7681702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a66a0dfb9fec945b66e14eeb5d7681702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456bf58a14b089b3562932225a556527" id="r_a456bf58a14b089b3562932225a556527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456bf58a14b089b3562932225a556527">operator=</a> (const <a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp;)=delete</td></tr>
<tr class="memdesc:a456bf58a14b089b3562932225a556527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator is deleted.  <br /></td></tr>
<tr class="separator:a456bf58a14b089b3562932225a556527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8e03d6d843f178dacbdc0431d49e92" id="r_a5c8e03d6d843f178dacbdc0431d49e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c8e03d6d843f178dacbdc0431d49e92">lock</a> (void)</td></tr>
<tr class="memdesc:a5c8e03d6d843f178dacbdc0431d49e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the mutex.  <br /></td></tr>
<tr class="separator:a5c8e03d6d843f178dacbdc0431d49e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb72e86c011b82f7ec1743a9a6994e" id="r_a25eb72e86c011b82f7ec1743a9a6994e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25eb72e86c011b82f7ec1743a9a6994e">unlock</a> (void)</td></tr>
<tr class="memdesc:a25eb72e86c011b82f7ec1743a9a6994e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the mutex.  <br /></td></tr>
<tr class="separator:a25eb72e86c011b82f7ec1743a9a6994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Synchronize execution from a thread with the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019-01-19</dd></dl>
<p>This class is used to synchronize the execution of a thread with the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread so that it is safe to access resources owned by the main thread that otherwise does not know about thread synchronization. When a thread holds the lock the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread is guaranteed to be in a safe place. All other threads trying to get the same lock will be blocked until the thread holding the lock release it.</p>
<p>As always with locks, try to hold the lock the shortest time possible since it will block the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread while the lock is held. That for example means that no timer handlers nor file descriptor watch handlers will be called</p>
<p>Note that locking this mutex is almost always expensive since the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread own the lock if no other thread owns it. The main thread must then get to a safe place before the mutex can be locked by another thread. Only use this mutex if synchronization with the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread is needed. If the purpose is to only synchronize between other threads, use a standard mutex. A standard mutex is also sufficient if synchronizing access to some data structure that you have full control over.</p>
<p>Note that all instances of Async::Mutexes are connected so that if one instance is locked, no other instance can be locked. That is, the other threads wanting to lock an <a class="el" href="classAsync_1_1Mutex.html" title="Synchronize execution from a thread with the main Async thread.">Async::Mutex</a> will be blocked while waiting for the lock to be unlocked.</p>
<p>The <a class="el" href="classAsync_1_1Mutex.html" title="Synchronize execution from a thread with the main Async thread.">Async::Mutex</a> may be used with standard C++ constructs like lock_guard, unique_lock, condition_variable_any, etc.</p>
<div class="fragment"></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AsyncMutex_8h_source.html#l00142">142</a> of file <a class="el" href="AsyncMutex_8h_source.html">AsyncMutex.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a51117fdd230652796c40cac6d1cafacf" name="a51117fdd230652796c40cac6d1cafacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51117fdd230652796c40cac6d1cafacf">&#9670;&#160;</a></span>Mutex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Async::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>A mutex must be created on the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread. Also it cannot be created before an <a class="el" href="classAsync_1_1Application.html" title="The base class for asynchronous applications.">Async::Application</a> has been created. This means that an <a class="el" href="classAsync_1_1Mutex.html" title="Synchronize execution from a thread with the main Async thread.">Async::Mutex</a> cannot be declared as a global variable since those are initialized before the main function is called. </p>

</div>
</div>
<a id="a490beb71934a5bc879027ea4c64ffe3c" name="a490beb71934a5bc879027ea4c64ffe3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490beb71934a5bc879027ea4c64ffe3c">&#9670;&#160;</a></span>Mutex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Async::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is deleted. </p>

</div>
</div>
<a id="a66a0dfb9fec945b66e14eeb5d7681702" name="a66a0dfb9fec945b66e14eeb5d7681702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a0dfb9fec945b66e14eeb5d7681702">&#9670;&#160;</a></span>~Mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Async::Mutex::~Mutex </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>A mutex must be destructed on the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread.</p>
<p>The behavior is undefined if the mutex is owned by any thread or if any thread terminates while holding any ownership of the mutex. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c8e03d6d843f178dacbdc0431d49e92" name="a5c8e03d6d843f178dacbdc0431d49e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8e03d6d843f178dacbdc0431d49e92">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Mutex::lock </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the mutex. </p>
<p>Calling this function will lock the mutex if it's not already locked by another thread. If the lock is held by another thread this thread will block until the lock can be acquired. NOTE: If called from the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread it's a noop since if we already are executing in the main thread we by definition own the lock. </p>

</div>
</div>
<a id="a456bf58a14b089b3562932225a556527" name="a456bf58a14b089b3562932225a556527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456bf58a14b089b3562932225a556527">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp; Async::Mutex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAsync_1_1Mutex.html">Mutex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator is deleted. </p>

</div>
</div>
<a id="a25eb72e86c011b82f7ec1743a9a6994e" name="a25eb72e86c011b82f7ec1743a9a6994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25eb72e86c011b82f7ec1743a9a6994e">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Mutex::unlock </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the mutex. </p>
<p>Unlock a previously locked mutex. It is not allowed to call this function if the calling thread does not own the lock. NOTE: If called from the main <a class="el" href="namespaceAsync.html" title="Namespace for the asynchronous programming classes.">Async</a> thread it's a noop since if we already are executing in the main thread we by definition own the lock. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncMutex_8h_source.html">AsyncMutex.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 4 2025 14:24:10 for Async by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
